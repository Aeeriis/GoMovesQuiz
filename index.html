<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pok√©mon Go Moveset Energy Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="manifest" href="manifest.json">
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #fafaff; }
    .container { max-width: 480px; margin: auto; padding: 1em; }
    .disclaimer {
      font-size: 0.98em;
      color: #505050;
      background: #eef3ff;
      border-radius: 8px;
      padding: 0.7em 1em;
      margin-bottom: 1.2em;
      margin-top: 0.7em;
      text-align: center;
      border: 1px solid #d0d8e8;
    }
    .copyright {
      font-size: 0.83em;
      color: #666;
      text-align: center;
      margin-top: 2.3em;
      margin-bottom: 0.7em;
      padding: 0 0.6em;
      line-height: 1.5;
    }
    h1 { font-size: 1.6em; }
    .quiz-section { margin-top: 2em; }
    .result { margin-top: 1em; font-weight: bold; }
    input[type="number"] { width: %; font-size: 1.2em; }
    button { font-size: 1.1em; padding: 0.6em 1.2em; margin-top: 1em;}
    label { font-size: 1.1em; }
    #question { font-size: 1.15em; margin-bottom: 1em; }
    #stats { font-size: 1.1em; margin: 0.8em 0; }
    #avgstats { font-size: 1em; margin: 0.2em 0 0.8em 0; color: #234;}
    #xpstats { font-size: 1.1em; margin: 0.1em 0 0.7em 0; color: #096; font-weight: bold;}
    #levelstats { font-size: 1.15em; margin: 0.4em 0 0.7em 0; color: #1e2a; font-weight: bold;}
    #levelupReward { font-size: 1.2em; margin: 0.6em 0 1em 0; text-align: center; }
    #difficultySelect, #timerToggle { font-size: 1em; margin-bottom: 1em;}
    #difficultyWrap { margin-bottom: 0.2em; }
    #metaSettingsWrap {
      margin: 1.2em 0 0.5em 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #metaBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.4em;
      display: flex;
      align-items: center;
      gap: 1.3em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
      flex-wrap: wrap;
    }
    #metaSelect {
      font-size: 1em;
      margin-right: 1.2em;
    }
    #metaToggleWrap {
      display: flex;
      flex-wrap: wrap;
      gap: 1.1em;
      margin-bottom: 0.15em;
      margin-left: 0.1em;
      margin-top: 0.12em;
      align-items: center;
    }
    #metaScoreLabel, #metaPrefLabel, #noTrickLabel {
      font-size: 0.97em;
      font-weight: bold;
      user-select: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 0;
      padding: 0;
    }
    #metaScore, #metaPref, #noTrick {
      vertical-align: middle;
      margin-right: 0.4em;
      accent-color: #228be6;
    }
    #metaScoreExplain, #metaPrefExplain, #noTrickExplain {
      font-size: 0.93em;
      color: #234;
      margin-top: 0.15em;
      margin-bottom: 0.13em;
      line-height: 1.35;
      padding-left: 0.1em;
    }
    #intro-explanation { margin: 1.1em 0 0.7em 0; background: #f0f7ff; border-radius: 8px; padding: 0.8em; font-size: 1.07em; color: #234; }
    #fixedNextWrap {
      display: none;
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: transparent;
      z-index: 100;
      text-align: center;
      pointer-events: none;
    }
    #fixedNextWrap.show {
      display: block;
    }
    #fixedNextBtn {
      font-size: 1.18em;
      padding: 0.75em 2.2em;
      background: #fff;
      color: #228be6;
      border: 2.5px solid #228be6;
      border-radius: 32px;
      box-shadow: 0 2px 14px #228be644, 0 1.5px 0 #eee inset;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2.5em;
      pointer-events: auto;
      transition: background .18s, color .18s, border .18s;
      position: relative;
    }
    #fixedNextBtn:hover, #fixedNextBtn:focus {
      background: #228be6;
      color: #fff;
      border-color: #228be6;
      outline: none;
    }
    #fixedNextBtn:active {
      background: #1864ab;
      color: #fff;
      border-color: #1864ab;
    }
    #fixedNextBtnWrap {
      display: inline-block;
      position: relative;
    }
    #timerSettingsWrap {
      margin-bottom: 1em;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #timerBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.8em;
      display: flex;
      align-items: center;
      gap: 1.2em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
    }
    #timer {
      min-width: 7em;
      font-weight: bold;
      display: inline-block;
      text-align: left;
      visibility: hidden;
      transition: opacity 0.2s;
    }
    .timer-visible {
      visibility: visible !important;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 28px;
      vertical-align: middle;
      margin-right: 0.5em;
      flex-shrink: 0;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .3s;
      border-radius: 34px;
      border: 2.5px solid #bbb;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 2.7px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px #0001;
    }
    input:checked + .slider {
      background-color: #228be6;
      border-color: #228be6;
    }
    input:checked + .slider:before {
      transform: translateX(17px);
    }
    #timerToggleLabel {
      font-size: 1.07em;
      user-select: none;
      cursor: pointer;
      font-weight: bold;
      display: flex;
      align-items: center;
      margin-left: 0em;
      margin-top: 0.33em;
    }
    @media (max-width: 600px) {
      h1 { font-size: 1.2em; }
      .container { padding: 0.5em; }
      #intro-explanation { font-size: 0.97em; }
      #fixedNextBtn { font-size: 1em; padding: 0.7em 1.5em; }
      #fixedNextWrap { padding-bottom: 0em; }
      #timerBox { font-size: 1em; gap: 0.7em; }
      #timerToggleLabel { font-size: 1em; }
      #fixedNextBtn { margin-bottom: 2em; }
      #metaBox {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.3em;
      }
      #metaToggleWrap {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35em;
        margin-bottom: 0.2em;
        margin-left: 0;
      }
      #metaScoreExplain, #metaPrefExplain, #noTrickExplain { font-size: 0.88em; padding-left: 0.3em; }
      .disclaimer { font-size: 0.95em; padding: 0.56em 0.7em; }
      .copyright { font-size: 0.78em; }
    }
    button.main-action, .main-action {
      font-size: 1.1em;
      padding: 0.6em 1.2em;
      margin: 0.5em 0;
      border-radius: 6px;
      background: #fff;
      color: #228be6;
      border: 2px solid #228be6;
      font-weight: bold;
      cursor: pointer;
      transition: background .18s, color .18s, border .18s;
      box-sizing: border-box;
      display: inline-block;
    }

    button.main-action:hover, .main-action:hover,
    button.main-action:focus, .main-action:focus {
      background: #228be6;
      color: #fff;
      border-color: #228be6;
      outline: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="disclaimer">
      <b>Disclaimer:</b> This entire app was created by AI (GitHub Copilot). All gameplay and meta data used here are from <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a>.
    </div>
    <h1>Pok√©mon Go Moveset Energy Quiz</h1>
    <button id="openTradeupMenu" class="main-action">Fruit Trade Up</button>
    <button id="openFruitEncyclopedia" class="main-action">Fruit Encyclopedia</button>
    <!-- Add this in your HTML, e.g. below the Fruit Encyclopedia button: -->
    <button id="openDailyChallenge" class="main-action">Daily Challenge üçÄ</button>
    <button id="openFeedback" class="main-action">Feedback</button>

    <!-- Daily Challenge Modal -->
    <div id="dailyChallengeModal" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; 
      background:rgba(0,0,0,0.4); z-index:9999; align-items:center; justify-content:center;">
      <div style="background:#fff; border-radius:10px; max-width:430px; margin:auto; padding:1.2em; box-shadow:0 8px 32px #0004; position:relative;">
        <button id="closeDailyChallenge" style="position:absolute; right:0.7em; top:0.7em; font-size:1.4em; background:none; border:none; color:#666; cursor:pointer;">√ó</button>
        <div style="font-size:1.3em; font-weight:bold; text-align:center; margin-bottom:0.6em;">Daily Challenge üçÄ</div>
        <div id="dailyChallengeBody" style="margin-top:0.3em; font-size:1.13em; text-align:center;">
      <!-- Filled by JS -->
        </div>
      </div>
    </div>
    <!-- Feedback Modal -->
    <div id="feedbackModal" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh;
      background:rgba(0,0,0,0.4); z-index:9999; align-items:center; justify-content:center;">
      <div style="background:#fff; border-radius:10px; max-width:430px; margin:auto; padding:1.2em; box-shadow:0 8px 32px #0004; position:relative;">
        <button id="closeFeedbackModal" style="position:absolute; right:0.7em; top:0.7em; font-size:1.4em; background:none; border:none; color:#666; cursor:pointer;">√ó</button>
        <div style="font-size:1.3em; font-weight:bold; text-align:center; margin-bottom:0.6em;">Feedback</div>
        <form action="https://formspree.io/f/meogyrvw" method="POST" style="display:flex;flex-direction:column;gap:0.5em;">
          <textarea name="feedback" required style="width:100%;font-size:1.1em;"></textarea>
          <button type="submit" class="main-action" style="width:100%;margin-top:0.5em;">Send Feedback</button>
        </form>
        <div id="feedbackThanks" style="display:none; color:green; text-align:center; margin-top:0.7em;">Thank you for your feedback!</div>
      </div>
    </div>
    <div id="intro-explanation">
      <b>How the quiz works:</b>
      <ul>
        <li><b>Basic</b> ‚Äì How many fast moves do you need for the <u>first</u> charged move?</li>
        <li><b>Multi-Charge</b> ‚Äì How many fast moves do you need for the <u>1st, 2nd, 3rd, or 4th</u> charged move?</li>
        <li><b>Combo</b> ‚Äì After using a certain number of one charged move, how many fast moves are needed for a different charged move? (Combo mode now also includes Multi-Charge questions; combo questions are 1/3 of the total)</li>
      </ul>
      After each answer, an explanation with energy breakdown is shown to help you learn!
    </div>
    <div id="difficultyWrap">
      <label for="difficultySelect"><b>Difficulty:</b></label>
      <select id="difficultySelect">
        <option value="basic">Basic</option>
        <option value="multi">Multi-Charge</option>
        <option value="combo">Combo</option>
      </select>
    </div>
    <div id="metaSettingsWrap">
      <div id="metaBox">
        <label for="metaSelect"><b>Meta:</b></label>
        <select id="metaSelect"></select>
      </div>
      <div id="metaToggleWrap">
        <label id="metaScoreLabel" title="Only show Pok√©mon with score above 80 in this meta">
          <input type="checkbox" id="metaScore" />
          Only Score &gt; 80
        </label>
        <label id="metaPrefLabel" title="Only use preferred movesets for each Pok√©mon (from PvPoke meta)">
          <input type="checkbox" id="metaPref" />
          Preferred moveset only
        </label>
        <label id="noTrickLabel" title="Avoid 'trick questions' where every charged move always leaves 0 energy (e.g. Extrasensory/Rock Tomb)">
          <input type="checkbox" id="noTrick" />
          Avoid trick questions
        </label>
      </div>
      <div id="metaScoreExplain">
        <b>What does "Score &gt; 80" mean?</b><br>
        This limits the Pok√©mon pool to only those with an <b>overall score above 80 in the selected meta on <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a></b>.<br>
        Higher overall score means the Pok√©mon is more competitively viable in that meta.
      </div>
      <div id="metaPrefExplain">
        <b>What does "Preferred moveset only" mean?</b><br>
        This only asks about the best/most recommended movesets for each Pok√©mon, as listed in the selected meta's CSV (columns <b>Fast Move</b>, <b>Charged Move 1</b> and <b>Charged Move 2</b>).
      </div>
      <div id="noTrickExplain">
        <b>What does "Avoid trick questions" mean?</b><br>
        Some fast/charged move combinations (e.g. Extrasensory and Rock Tomb) always leave you with exactly 0 energy after each charged move, which means the answer for the 2nd, 3rd, etc. charged move is always exactly the same as the 1st (no leftover energy ever). When enabled, this setting avoids generating these repetitive, "trick" questions.
      </div>
      <div id="metaWarn" style="color:#b00;font-size:0.98em;padding:0.1em 0 0.2em 0;"></div>
      <div style="font-size:0.9em;color:#888;margin-top:0.2em;">
        <span>Metas loaded from <a href="https://github.com/Aeeriis/GoMovesQuiz/tree/main/rankings" target="_blank">GitHub rankings/</a> folder.</span>
      </div>
    </div>
    <div id="timerSettingsWrap">
      <label id="timerToggleLabel">
        <span class="switch">
          <input type="checkbox" id="timerToggle">
          <span class="slider"></span>
        </span>
        Show time
      </label>
      <div id="timerBox">
        <span id="timer"></span>
      </div>
    </div>
    <div id="levelstats"></div>
    <div id="xpstats"></div>
    <div id="tradeupModal" style="
      display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; 
      background:rgba(0,0,0,0.4); z-index:9999; align-items:center; justify-content:center;">
      <div style="
        background:#fff; border-radius:10px; max-width:350px; margin:auto; padding:1.2em; box-shadow:0 8px 32px #0004; position:relative;">
        <button id="closeTradeupMenu" style="position:absolute; right:0.7em; top:0.7em; font-size:1.4em; background:none; border:none; color:#666; cursor:pointer;">√ó</button>
        <div id="tradeupSection" style="text-align:center;">
          <b>Trade Up Fruits</b><br>
          <div id="tradeupTiers"></div>
          <div id="tradeupMsg" style="color:#1864ab;font-size:0.97em;margin-top:0.5em;"></div>
        </div>
      </div>
    </div>
    <div id="fruitEncyclopediaModal" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; 
      background:rgba(0,0,0,0.4); z-index:9999; align-items:center; justify-content:center;">
      <div style="background:#fff; border-radius:10px; max-width:420px; margin:auto; padding:1.2em; box-shadow:0 8px 32px #0004; position:relative;">
        <button id="closeFruitEncyclopedia" style="position:absolute; right:0.7em; top:0.7em; font-size:1.4em; background:none; border:none; color:#666; cursor:pointer;">√ó</button>
        <div style="font-size:1.3em; font-weight:bold; text-align:center;">Fruit Encyclopedia</div>
        <div id="fruitEncyclopediaBody" style="margin-top:1.3em; font-size:1.18em; text-align:center;">
          <!-- Content rendered by JS -->
        </div>
      </div>
    </div>
    <div id="levelupReward"></div>
    <div id="stats"></div>
    <div id="avgstats"></div>
    <div id="loading">Loading data...</div>
    <div class="quiz-section hidden" id="quizSection">
      <div id="question"></div>
      <form id="answerForm">
        <label for="userAnswer">Your answer:</label>
        <input type="number" id="userAnswer" min="1" required autocomplete="off" />
        <button type="submit">Check</button>
      </form>
      <div class="result" id="result"></div>
      <button id="nextQuestion" class="hidden" style="display:none;">Next Question</button>
      <button id="resetStats" style="margin-top:1em;">Reset Stats</button>
    </div>
  </div>
  <div class="copyright">
    Pok√©mon and Pok√©mon GO are copyright of The Pok√©mon Company, Niantic, Inc., and Nintendo. All trademarked images and names are property of their respective owners, and any such material is used on this site for educational purposes only.
  </div>
  <div id="fixedNextWrap">
    <span id="fixedNextBtnWrap">
      <button id="fixedNextBtn" type="button">Next Question</button>
    </span>
  </div>
  <script>
    // --- ANTI-FARMING STATE ---
    // This flag determines if XP has already been awarded for the current question
    let xpAwardedForCurrentQuestion = false;

    // --- XP / LEVELS / REWARDS ---
    const LEVELUP_REWARDS = [
      { emoji: "üçé", name: "Apple",        rarity: "üü¢ Common", prob: 10, rarityKey: "Common" },
      { emoji: "üçå", name: "Banana",       rarity: "üü¢ Common", prob: 10, rarityKey: "Common" },
      { emoji: "üçä", name: "Orange",       rarity: "üü¢ Common", prob: 10, rarityKey: "Common" },
      { emoji: "üçá", name: "Grapes",       rarity: "üü¢ Common", prob: 10, rarityKey: "Common" },
      { emoji: "üçâ", name: "Watermelon",   rarity: "üü¢ Common", prob: 10, rarityKey: "Common" },
      { emoji: "ü•ù", name: "Kiwi",         rarity: "üîµ Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "üçè", name: "Pomegranate",  rarity: "üîµ Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "ü•≠", name: "Mango",        rarity: "üîµ Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "üçê", name: "Pear",         rarity: "üîµ Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "ü´ê", name: "Blueberries",  rarity: "üîµ Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "üêâ", name: "Dragon fruit", rarity: "üü£ Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "üçà", name: "Passion fruit",rarity: "üü£ Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "üåü", name: "Starfruit",    rarity: "üü£ Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "üçí", name: "Lychee",       rarity: "üü£ Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "üçë", name: "Persimmon",    rarity: "üü£ Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "ü••", name: "Mangosteen",   rarity: "üü† Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "üé±", name: "Rambutan",     rarity: "üü† Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "ü™∑", name: "Buddha‚Äôs Hand",prob: 2, rarity: "üü† Epic", rarityKey: "Epic" },
      { emoji: "üêç", name: "Salak",        rarity: "üü† Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "üçÑ", name: "Miracle Fruit",rarity: "üî¥ Legendary", prob: 0.67, rarityKey: "Legendary" },
      { emoji: "ü§¢", name: "Durian",       rarity: "üî¥ Legendary", prob: 0.67, rarityKey: "Legendary" },
      { emoji: "üç´", name: "Cupua√ßu",      rarity: "üî¥ Legendary", prob: 0.66, rarityKey: "Legendary" }
    ];
    const TRADEUP_MAP = [
      { from: "Common", to: "Uncommon", cost: 5 },
      { from: "Uncommon", to: "Rare", cost: 5 },
      { from: "Rare", to: "Epic", cost: 5 },
      { from: "Epic", to: "Legendary", cost: 5 }
    ];
    function calcXP(difficulty, onlyHighScore) {
      let base = 12;
      if (difficulty === "multi") base = 18;
      else if (difficulty === "combo") base = 23;
      if (onlyHighScore) base = Math.round(base * 0.85);
      return base;
    }
    function getLevelInfo(xp) {
      let level = 1, total = 0, next = 45;
      while (xp >= total + next) {
        total += next;
        level++;
        next = level * 45;
      }
      return { level, xpInLevel: xp - total, xpToNext: next - (xp - total), xpForNext: next };
    }
    function getRandomFruitReward() {
      let r = Math.random() * 100, acc = 0;
      for (let fruit of LEVELUP_REWARDS) {
        acc += fruit.prob;
        if (r < acc) return fruit;
      }
      return LEVELUP_REWARDS[0];
    }
    let xpState = JSON.parse(localStorage.getItem('quizXP') || '{"xp":0,"fruitBag":{}}');
    if (!xpState.fruitBag) xpState.fruitBag = {};
    if (!xpState.discoveredFruits) xpState.discoveredFruits = {}; // <-- add this line
    for (let emoji in xpState.fruitBag) {
      if ((xpState.fruitBag[emoji] || 0) > 0) {
        xpState.discoveredFruits[emoji] = true;
      }
    }
    saveXP();
    function saveXP() { localStorage.setItem('quizXP', JSON.stringify(xpState)); }
    function showXP() {
      const info = getLevelInfo(xpState.xp);
      document.getElementById('levelstats').textContent =
        `Level ${info.level}  |  XP: ${xpState.xp}  |  Next: ${info.xpToNext} XP`;
      let rarityOrder = ["Common","Uncommon","Rare","Epic","Legendary"];
      let rarityTitles = {
        Common: "üü¢ Common",
        Uncommon: "üîµ Uncommon",
        Rare: "üü£ Rare",
        Epic: "üü† Epic",
        Legendary: "üî¥ Legendary"
      };
      let bagByRarity = {};
      for (let fruit of LEVELUP_REWARDS) {
        let count = xpState.fruitBag[fruit.emoji] || 0;
        if (count === 0) continue;
        if (!bagByRarity[fruit.rarityKey]) bagByRarity[fruit.rarityKey] = [];
        bagByRarity[fruit.rarityKey].push({ ...fruit, count });
      }
      let bagHTML = rarityOrder.map(rarity => {
        let arr = bagByRarity[rarity];
        if (!arr || arr.length === 0) return "";
        let fruitsHTML = arr.map(f =>
          `<span title="${f.name}" style="font-size:1.4em;margin-right:0.05em">${f.emoji}√ó${f.count}</span>`
        ).join(" ");
        return `<div><span style="font-size:1.04em">${rarityTitles[rarity]}:</span> ${fruitsHTML}</div>`;
      }).join("");
      document.getElementById('xpstats').innerHTML =
        bagHTML ? `<div style="margin-top:0.2em">${bagHTML}</div>` : "";
    }
    function showLevelupReward(fruit) {
      let div = document.getElementById("levelupReward");
      if (!fruit) { div.textContent = ""; return; }
      div.innerHTML =
        `<span style="font-size:2em;">${fruit.emoji}</span><br>` +
        `<b>Level Up!</b> You received a <b>${fruit.rarity} ${fruit.name}</b>!`;
      setTimeout(() => { div.textContent = ""; }, 5500);
    }
    // -- Meta settings (CSV file list) --
    const metaCSVFILES = [
      { file: "cp1500_all_overall_rankings.csv", label: "Great" },
      { file: "cp2500_all_overall_rankings.csv", label: "Ultra" },
      { file: "cp10000_all_overall_rankings.csv", label: "Master" },
      { file: "cp1500_tempo_overall_rankings.csv", label: "Tempo" },
      { file: "cp1500_wasteland_overall_rankings.csv", label: "Wasteland" },
      { file: "cp2500_battlefrontierultra_overall_rankings.csv", label: "Battlefrontier Ultra" },
      { file: "cp10000_battlefrontiermaster_overall_rankings.csv", label: "Battlefrontier Master" },
      { file: "cp1500_gbinvitational_overall_rankings.csv", label: "Gymbreakers Invitational" },
      { file: "cp1500_tundraremixv2_overall_rankings.csv", label: "Gymbreakers Tundra Remix" },
      { file: "cp1500_rivalry_overall_rankings.csv", label: "Rivalry" },
      { file: "cp1500_sunshine_overall_rankings.csv", label: "Sunshine Cup" },
      { file: "cp1500_fossil_overall_rankings.csv", label: "Fossil Cup" }
    ];
    const githubUser = "Aeeriis";
    const githubRepo = "GoMovesQuiz";
    const metaRootURL = `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/main/rankings/`;

    let metaPokes = [];
    let metaPreferred = {};
    let currentMeta = localStorage.getItem("quizMeta") || metaCSVFILES[0].file;
    let onlyHighScore = localStorage.getItem("onlyHighScore") === "true";
    let onlyPreferredMoveset = localStorage.getItem("onlyPreferredMoveset") === "true";
    let avoidTrickQuestions = localStorage.getItem("avoidTrickQuestions") === "true";

    function populateMetaMenu() {
      const metaSelect = document.getElementById('metaSelect');
      metaSelect.innerHTML = "";
      metaCSVFILES.forEach(meta => {
        let opt = document.createElement("option");
        opt.value = meta.file;
        opt.textContent = meta.label;
        metaSelect.appendChild(opt);
      });
      metaSelect.value = currentMeta;
      document.getElementById('metaScore').checked = onlyHighScore;
      document.getElementById('metaPref').checked = onlyPreferredMoveset;
      document.getElementById('noTrick').checked = avoidTrickQuestions;
      loadMetaAndApply();
    }
    document.getElementById('metaSelect').onchange = function() {
      currentMeta = this.value;
      localStorage.setItem("quizMeta", currentMeta);
      loadMetaAndApply();
    };
    document.getElementById('metaScore').onchange = function() {
      onlyHighScore = this.checked;
      localStorage.setItem("onlyHighScore", onlyHighScore);
      loadMetaAndApply();
    };
    document.getElementById('metaPref').onchange = function() {
      onlyPreferredMoveset = this.checked;
      localStorage.setItem("onlyPreferredMoveset", onlyPreferredMoveset);
      loadMetaAndApply();
    };
    document.getElementById('noTrick').onchange = function() {
      avoidTrickQuestions = this.checked;
      localStorage.setItem("avoidTrickQuestions", avoidTrickQuestions);
      loadMetaAndApply();
    };

    function loadMetaAndApply() {
      document.getElementById('metaWarn').textContent = "";
      metaPreferred = {};
      if (!currentMeta) { metaPokes = []; return; }
      fetch(metaRootURL + encodeURIComponent(currentMeta))
        .then(r => r.text())
        .then(csv => {
          const lines = csv.trim().split(/\r?\n/);
          if (lines.length < 2) {
            metaPokes = [];
            document.getElementById('metaWarn').textContent = "No Pok√©mon found for this meta.";
            return;
          }
          const head = lines[0].split(",");
          const idxName = head.findIndex(h => h.trim().toLowerCase() === "pokemon");
          const idxScore = head.findIndex(h => h.trim().toLowerCase() === "score");
          const idxFM = head.findIndex(h => h.trim().toLowerCase() === "fast move");
          const idxC1 = head.findIndex(h => h.trim().toLowerCase() === "charged move 1");
          const idxC2 = head.findIndex(h => h.trim().toLowerCase() === "charged move 2");
          if (idxName === -1 || idxScore === -1) {
            metaPokes = [];
            document.getElementById('metaWarn').textContent = "Meta CSV missing Pokemon or Score column.";
            return;
          }
          metaPokes = [];
          metaPreferred = {};
          lines.slice(1).forEach(rowstr => {
            const row = rowstr.split(",");
            const name = row[idxName];
            const score = parseFloat(row[idxScore]);
            if (!onlyHighScore || score > 93) {
              metaPokes.push(name);
            }
            if (idxFM !== -1 && idxC1 !== -1 && idxC2 !== -1) {
              metaPreferred[name] = {
                fast: row[idxFM],
                charge1: row[idxC1],
                charge2: row[idxC2]
              };
            }
          });
          if (!metaPokes.length) {
            document.getElementById('metaWarn').textContent = "No Pok√©mon with Score > 80 in this meta.";
          }
          newQuestion();
        });
    }

    function isTrickCombo(fastEnergy, chargeEnergy) {
      if (!fastEnergy || !chargeEnergy) return false;
      return (chargeEnergy % fastEnergy === 0);
    }

    let stats = JSON.parse(localStorage.getItem('quizStats') ||
      '{"total":0,"correct":0,"sumTime":0,"sumTimeRight":0,"rightCount":0}');
    if (stats.sumTime === undefined) stats.sumTime = 0;
    if (stats.sumTimeRight === undefined) stats.sumTimeRight = 0;
    if (stats.rightCount === undefined) stats.rightCount = stats.correct || 0;
    function saveStats() {
      localStorage.setItem('quizStats', JSON.stringify(stats));
    }
    function showStats() {
      document.getElementById('stats').textContent =
        `Score: ${stats.correct}/${stats.total} (${stats.total ? Math.round(100 * stats.correct / stats.total) : 0}%)`;
      let avg = stats.total ? (stats.sumTime / stats.total) : 0;
      let avgRight = stats.rightCount ? (stats.sumTimeRight / stats.rightCount) : 0;
      document.getElementById('avgstats').textContent =
        `Average time: ${stats.total ? avg.toFixed(2) + " s" : "-"}   |   Average for correct: ${stats.rightCount ? avgRight.toFixed(2) + " s" : "-"}`;
    }
    showStats();
    showXP();
    let timerStart = null, timerInterval = null, timerActive = false;
    const timerSpan = document.getElementById('timer');
    const timerBox = document.getElementById('timerBox');
    const timerToggle = document.getElementById('timerToggle');
    const timerToggleLabel = document.getElementById('timerToggleLabel');
    let timerEnabled = localStorage.getItem('timerEnabled');
    if (timerEnabled === null) timerEnabled = "true";
    timerEnabled = timerEnabled === "true";
    timerToggle.checked = timerEnabled;
    function updateTimerVisibilityOnQuestion() {
      timerSpan.classList.remove('timer-visible');
      timerSpan.textContent = "";
    }
    function updateTimerVisibilityOnAnswer(timeText) {
      if (timerEnabled && timeText) {
        timerSpan.textContent = timeText;
        timerSpan.classList.add('timer-visible');
      } else {
        timerSpan.classList.remove('timer-visible');
        timerSpan.textContent = "";
      }
    }
    timerToggle.onchange = function() {
      timerEnabled = timerToggle.checked;
      localStorage.setItem('timerEnabled', timerEnabled ? "true" : "false");
      if (!timerEnabled) updateTimerVisibilityOnAnswer();
    };
    function startTimer() {
      timerStart = Date.now();
      timerActive = true;
      timerSpan.classList.remove('timer-visible');
      timerSpan.textContent = "";
      if (timerInterval) clearInterval(timerInterval);
    }
    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      timerActive = false;
    }
    function getTimerElapsed() {
      if (!timerStart) return 0;
      return (Date.now() - timerStart) / 1000;
    }
    let difficulty = localStorage.getItem("quizDifficulty") || "multi";
    document.getElementById('difficultySelect').value = difficulty;
    document.getElementById('difficultySelect').onchange = function() {
      difficulty = this.value;
      localStorage.setItem("quizDifficulty", difficulty);
      newQuestion();
    };
    document.getElementById('resetStats').onclick = function() {
      if (!window.confirm("Are you sure you want to reset your stats, XP, and fruit collection?")) return;
      stats = { total: 0, correct: 0, sumTime: 0, sumTimeRight: 0, rightCount: 0 };
      saveStats();
      showStats();
      xpState = { xp: 0, fruitBag: {}, discoveredFruits: {} };
      saveXP();
      showXP();
    };
    function getOrdinalText(n) {
      return ["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th"][n-1] || (n+"th");
    }
    function getExplanation(pair) {
      let fastName = pair.fast.Move;
      let fastEnergy = pair.fast.Energy;
      if (pair.isCombo) {
        let chargeA = pair.combo.chargeA, nA = pair.combo.nA, chargeB = pair.charge;
        let explanation =
          `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
          `First, ${nA} <b>${chargeA.Move}</b> (Charged) are used. Each costs <b>${chargeA.Energy}</b> energy.<br>`;
        let log = [];
        let energy = 0, totalFasts = 0;
        for (let i=1; i<=nA; ++i) {
          let thisFasts = 0, startEnergy = energy;
          let movesSoFar = [];
          while (energy < chargeA.Energy) {
            energy += fastEnergy;
            totalFasts++;
            thisFasts++;
            movesSoFar.push(startEnergy + thisFasts * fastEnergy);
          }
          log.push(`For the ${getOrdinalText(i)} ${chargeA.Move}:<br>` +
            `&nbsp;&nbsp;Start with <b>${startEnergy}</b> energy.<br>` +
            `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
            `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startEnergy + thisFasts * fastEnergy}</b> energy (‚â• ${chargeA.Energy} needed).<br>` +
            `&nbsp;&nbsp;You spend ${chargeA.Energy} for the charged move, leaving <b>${startEnergy + thisFasts*fastEnergy - chargeA.Energy}</b> energy for the next.<br>`
          );
          energy -= chargeA.Energy;
        }
        let beforeB = energy;
        let fastsForB = 0, breakdownB = [];
        let energyB = beforeB;
        while (energyB < chargeB.Energy) {
          energyB += fastEnergy;
          fastsForB++;
          breakdownB.push(beforeB + fastsForB * fastEnergy);
        }
        explanation += log.join('<br>') + `<br>After those, you have <b>${beforeB}</b> energy.<br>`;
        explanation += `Each fast attack gives <b>${fastEnergy}</b> energy: <b>${breakdownB.join(', ')}</b>.<br>`;
        explanation += `After ${fastsForB} fast attacks you have <b>${beforeB + fastsForB*fastEnergy}</b> energy (‚â• ${chargeB.Energy} needed).<br>`;
        explanation += `You spend ${chargeB.Energy} for the charged move, leaving <b>${beforeB + fastsForB*fastEnergy - chargeB.Energy}</b> energy for the next.<br>`;
        return explanation;
      } else {
        let chargeName = pair.charge.Move;
        let chargeEnergy = pair.charge.Energy;
        let n = pair.which;
        let explanation = 
          `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
          `You need <b>${chargeEnergy}</b> energy for each <b>${chargeName}</b> (Charged).<br>`;
        let breakdown = [];
        let energy = 0;
        for (let i = 1; i <= n; i++) {
          let thisFasts = 0;
          let startingEnergy = energy;
          let movesSoFar = [];
          while (energy < chargeEnergy) {
            energy += fastEnergy;
            thisFasts++;
            movesSoFar.push(startingEnergy + thisFasts * fastEnergy);
          }
          breakdown.push(
            `For the ${getOrdinalText(i)} charged move:<br>` +
            `&nbsp;&nbsp;Start with <b>${startingEnergy}</b> energy.<br>` +
            `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
            `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startingEnergy + thisFasts*fastEnergy}</b> energy (‚â• ${chargeEnergy} needed).<br>` +
            `&nbsp;&nbsp;You spend ${chargeEnergy} for the charged move, leaving <b>${startingEnergy + thisFasts*fastEnergy - chargeEnergy}</b> energy for the next.<br>`
          );
          energy -= chargeEnergy;
        }
        explanation += breakdown.join('<br>');
        return explanation;
      }
    }
    let moves = [], movesByName = {}, pokedex = [], currentPair = {};
    Promise.all([
      fetch('moves.csv').then(r => r.text()),
      fetch('pokemon.json').then(r => r.json())
    ]).then(([csvData, pokeData]) => {
      moves = parseCSV(csvData);
      movesByName = {};
      moves.forEach(mv => {
        movesByName[mv.Move.trim().toUpperCase().replace(/ /g, "_")] = mv;
        movesByName[mv.Move.trim()] = mv;
      });
      pokedex = pokeData;
      document.getElementById('loading').classList.add('hidden');
      document.getElementById('quizSection').classList.remove('hidden');
      showStats();
      showXP();
      populateMetaMenu();
    });
    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      return lines.slice(1).map(line => {
        let cells = [], cell = '', inQuotes = false;
        for (let ch of line) {
          if (ch === '"') inQuotes = !inQuotes;
          else if (ch === ',' && !inQuotes) { cells.push(cell); cell = ''; }
          else cell += ch;
        }
        cells.push(cell);
        let obj = {};
        headers.forEach((h, i) => {
          obj[h] = cells[i] !== undefined ? cells[i].trim() : '';
          if (['Energy'].includes(h)) {
            obj[h] = obj[h] === '' ? NaN : parseInt(obj[h], 10);
          }
        });
        return obj;
      });
    }

    function pickEligiblePokemon() {
      let eligible = pokedex.filter(poke => {
        let name = poke.speciesName;
        let fastList, chargeList;
        if (onlyPreferredMoveset && metaPreferred[name]) {
          fastList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
          chargeList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
        } else {
          fastList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
          chargeList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
        }
        return fastList.length && chargeList.length && (!metaPokes.length || metaPokes.includes(name));
      });
      if (!eligible.length) return null;
      return eligible[Math.floor(Math.random() * eligible.length)];
    }

    function getPreferredOrAllFastMoves(poke) {
      let name = poke.speciesName;
      if (onlyPreferredMoveset && metaPreferred[name]) {
        let fm = metaPreferred[name].fast;
        return [fm].filter(mv => !!movesByName[mv]);
      }
      return (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
    }
    function getPreferredOrAllChargeMoves(poke) {
      let name = poke.speciesName;
      if (onlyPreferredMoveset && metaPreferred[name]) {
        let c1 = metaPreferred[name].charge1;
        let c2 = metaPreferred[name].charge2;
        return [c1, c2].filter((mv, i, arr) => mv && arr.indexOf(mv) === i && !!movesByName[mv]);
      }
      return (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
    }

    function calcFastMovesForNthCharge(fastEnergy, chargeEnergy, n) {
      let energy = 0;
      let fastsToEachCharge = [];
      for(let i=1; i<=n; ++i) {
        let thisChargeFasts = 0;
        while (energy < chargeEnergy) {
          energy += fastEnergy;
          thisChargeFasts++;
        }
        energy -= chargeEnergy;
        fastsToEachCharge.push(thisChargeFasts);
      }
      return fastsToEachCharge[n-1];
    }
    function newQuestion() {
      // Reset anti-farming flag so XP can be awarded for the new question
      xpAwardedForCurrentQuestion = false;

      document.getElementById('result').textContent = '';
      document.getElementById('nextQuestion').classList.add('hidden');
      document.getElementById('userAnswer').value = '';
      showFixedNextButton(false);
      stopTimer();
      updateTimerVisibilityOnQuestion();
      if (!metaPokes.length) {
        document.getElementById('question').textContent = "No eligible Pok√©mon for this meta and filter.";
        document.getElementById('answerForm').classList.add('hidden');
        return;
      }
      if (difficulty === "basic") {
        let tries = 0, pokemon, fastList, chargeList, fast, charge;
        do {
          pokemon = pickEligiblePokemon();
          if (!pokemon) break;
          fastList = getPreferredOrAllFastMoves(pokemon);
          chargeList = getPreferredOrAllChargeMoves(pokemon);
          fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
          charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
          tries++;
        } while (
          avoidTrickQuestions &&
          isTrickCombo(fast.Energy, charge.Energy) &&
          tries < 30
        );
        if (!pokemon) {
          document.getElementById('question').textContent = 'No eligible Pok√©mon found. Please check your data files.';
          document.getElementById('answerForm').classList.add('hidden');
          return;
        }
        let which = 1; // Always 1st
        let nthText = getOrdinalText(which);
        let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
        currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
        document.getElementById('question').textContent =
          `How many "${fast.Move}" (Fast) are needed for the 1st "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
        document.getElementById('answerForm').classList.remove('hidden');
        startTimer();
        return;
      }
      if (difficulty === "combo") {
        if (Math.random() < 1/3) {
          let tries = 0, pokemon, fastList, chargeList, chargeAIdx, chargeBIdx, fast, chargeA, chargeB;
          do {
            let eligible = pokedex.filter(poke => {
              let name = poke.speciesName;
              let fList, cList;
              if (onlyPreferredMoveset && metaPreferred[name]) {
                fList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
                cList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
              } else {
                fList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
                cList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
              }
              return fList.length && cList.length >= 2 && (!metaPokes.length || metaPokes.includes(name));
            });
            if (!eligible.length) break;
            pokemon = eligible[Math.floor(Math.random() * eligible.length)];
            fastList = getPreferredOrAllFastMoves(pokemon);
            chargeList = getPreferredOrAllChargeMoves(pokemon);
            chargeAIdx = Math.floor(Math.random() * chargeList.length);
            do { chargeBIdx = Math.floor(Math.random() * chargeList.length); } while (chargeBIdx === chargeAIdx);
            fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
            chargeA = movesByName[chargeList[chargeAIdx]];
            chargeB = movesByName[chargeList[chargeBIdx]];
            tries++;
          } while (
            avoidTrickQuestions &&
            isTrickCombo(fast.Energy, chargeA.Energy) &&
            isTrickCombo(fast.Energy, chargeB.Energy) &&
            tries < 30
          );
          if (!pokemon) return newQuestion();
          let nA = 1 + Math.floor(Math.random() * 3); // 1-3 times
          let energy = 0, totalFasts = 0;
          for (let i=0; i<nA; ++i) {
            while (energy < chargeA.Energy) {
              energy += fast.Energy;
              totalFasts++;
            }
            energy -= chargeA.Energy;
          }
          let neededFastsForB = 0;
          let currentEnergy = energy;
          while (currentEnergy < chargeB.Energy) {
            currentEnergy += fast.Energy;
            neededFastsForB++;
          }
          currentPair = {
            fast, charge: chargeB, pokemon, needed: neededFastsForB, isCombo: true,
            combo: { chargeA, nA, leftover: energy }
          };
          document.getElementById('question').textContent =
            `${pokemon.speciesName} with ${fast.Move} (Fast) has thrown ${nA} ${chargeA.Move} (Charged).` +
            ` How many more ${fast.Move} are needed for a ${chargeB.Move} (Charged) now?`;
          document.getElementById('answerForm').classList.remove('hidden');
          startTimer();
          return;
        } else {
          let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
          do {
            pokemon = pickEligiblePokemon();
            if (!pokemon) break;
            fastList = getPreferredOrAllFastMoves(pokemon);
            chargeList = getPreferredOrAllChargeMoves(pokemon);
            fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
            charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
            which = 1 + Math.floor(Math.random() * 4); // 1~4
            tries++;
          } while (
            avoidTrickQuestions &&
            isTrickCombo(fast.Energy, charge.Energy) &&
            which > 1 &&
            tries < 30
          );
          if (!pokemon) {
            document.getElementById('question').textContent = 'No eligible Pok√©mon found. Please check your data files.';
            document.getElementById('answerForm').classList.add('hidden');
            return;
          }
          let nthText = getOrdinalText(which);
          let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
          currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
          document.getElementById('question').textContent =
            `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
          document.getElementById('answerForm').classList.remove('hidden');
          startTimer();
          return;
        }
      }
      let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
      do {
        pokemon = pickEligiblePokemon();
        if (!pokemon) break;
        fastList = getPreferredOrAllFastMoves(pokemon);
        chargeList = getPreferredOrAllChargeMoves(pokemon);
        fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
        charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
        which = 1 + Math.floor(Math.random() * 4); // 1~4
        tries++;
      } while (
        avoidTrickQuestions &&
        isTrickCombo(fast.Energy, charge.Energy) &&
        which > 1 &&
        tries < 30
      );
      if (!pokemon) {
        document.getElementById('question').textContent = 'No eligible Pok√©mon found. Please check your data files.';
        document.getElementById('answerForm').classList.add('hidden');
        return;
      }
      let nthText = getOrdinalText(which);
      let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
      currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
      document.getElementById('question').textContent =
        `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
      document.getElementById('answerForm').classList.remove('hidden');
      startTimer();
    }

    document.getElementById('answerForm').addEventListener('submit', function(e) {
      e.preventDefault();

      // --- Prevent XP farming: if XP has already been awarded for this question, just show the result and explanation, but do NOT give XP/stats again ---
      if (xpAwardedForCurrentQuestion) {
        // Show the result and explanation again, but do not update stats/xp
        const userAnswer = parseInt(document.getElementById('userAnswer').value, 10);
        let wasCorrect = (userAnswer === currentPair.needed);
        document.getElementById('result').textContent = wasCorrect ? '‚úÖ Correct!' : `‚ùå Incorrect. The correct answer is ${currentPair.needed}.`;
        let timeText = "";
        let elapsed = 0;
        if (timerEnabled && typeof timerStart === "number" && timerStart > 0) {
          elapsed = getTimerElapsed();
          timeText = "Answered in " + elapsed.toFixed(2) + " s";
        }
        updateTimerVisibilityOnAnswer(timeText);
        if (timerEnabled && timeText) {
          document.getElementById('result').innerHTML +=
            `<br><span style="color:#228be6;font-weight:bold;">${timeText}</span>`;
        }
        document.getElementById('result').innerHTML +=
          "<br><span style='font-size:0.95em;color:#555;'>" + getExplanation(currentPair) + "</span>";
        showFixedNextButton(true);
        return; // Early exit: do not award xp/stats again
      }

      stopTimer();
      const userAnswer = parseInt(document.getElementById('userAnswer').value, 10);
      let wasCorrect = false;
      if (userAnswer === currentPair.needed) {
        document.getElementById('result').textContent = '‚úÖ Correct!';
        wasCorrect = true;
      } else {
        document.getElementById('result').textContent =
          `‚ùå Incorrect. The correct answer is ${currentPair.needed}.`;
      }
      let timeText = "";
      let elapsed = 0;
      if (timerEnabled && typeof timerStart === "number" && timerStart > 0) {
        elapsed = getTimerElapsed();
        timeText = "Answered in " + elapsed.toFixed(2) + " s";
      }
      if (typeof elapsed === "number" && elapsed > 0) {
        stats.sumTime = (stats.sumTime || 0) + elapsed;
        if (wasCorrect) {
          stats.sumTimeRight = (stats.sumTimeRight || 0) + elapsed;
          stats.rightCount = (stats.rightCount || 0) + 1;
        }
      }
      updateTimerVisibilityOnAnswer(timeText);
      if (timerEnabled && timeText) {
        document.getElementById('result').innerHTML +=
          `<br><span style="color:#228be6;font-weight:bold;">${timeText}</span>`;
      }
      document.getElementById('result').innerHTML +=
        "<br><span style='font-size:0.95em;color:#555;'>" + getExplanation(currentPair) + "</span>";
      showFixedNextButton(true);

      stats.total++;
      if (wasCorrect) stats.correct++;
      saveStats();
      showStats();

      // --- AWARD XP ONLY ON FIRST SUBMIT for this question ---
      if (wasCorrect && !xpAwardedForCurrentQuestion) {
        xpAwardedForCurrentQuestion = true; // Mark this question as "xp already given"
        const xpGain = calcXP(difficulty, onlyHighScore);
        let prevXP = xpState.xp;
        xpState.xp += xpGain;
        let prevLevel = getLevelInfo(prevXP).level;
        let newLevel = getLevelInfo(xpState.xp).level;
        saveXP();
        showXP();
        if (newLevel > prevLevel) {
          let fruit = getRandomFruitReward();
          if (!xpState.fruitBag[fruit.emoji]) xpState.fruitBag[fruit.emoji] = 0;
          xpState.fruitBag[fruit.emoji]++;
          xpState.discoveredFruits[fruit.emoji] = true; // <-- add this line
          saveXP();
          showXP();
          showLevelupReward(fruit);
        } else {
          showLevelupReward(null);
        }
      } else {
        showLevelupReward(null);
      }
    });

    const fixedNextWrap = document.getElementById('fixedNextWrap');
    const fixedNextBtn = document.getElementById('fixedNextBtn');
    function showFixedNextButton(show) {
      if (show) fixedNextWrap.classList.add('show');
      else fixedNextWrap.classList.remove('show');
    }
    fixedNextBtn.onclick = function() {
      showFixedNextButton(false);
      newQuestion();
    };
    document.getElementById('nextQuestion').style.display = "none";
    function getFruitEmojisByRarity(rarityKey) {
      return LEVELUP_REWARDS.filter(f => f.rarityKey === rarityKey).map(f => f.emoji);
    }
    function getRandomFruitByRarity(rarityKey) {
      const fruits = LEVELUP_REWARDS.filter(f => f.rarityKey === rarityKey);
      return fruits[Math.floor(Math.random() * fruits.length)];
    }
    function tryTradeUp(fromKey, toKey, cost) {
  // Count total "from" fruits
      let fromEmojis = getFruitEmojisByRarity(fromKey);
      let total = fromEmojis.reduce((sum, emoji) => sum + (xpState.fruitBag[emoji] || 0), 0);
      if (total < cost) {
        return `Not enough ${fromKey} fruits!`;
      }
  // Remove fruits (evenly or randomly)
      let toRemove = cost;
      for (let emoji of fromEmojis) {
        let avail = xpState.fruitBag[emoji] || 0;
        let remove = Math.min(avail, toRemove);
        if (remove > 0) {
          xpState.fruitBag[emoji] = avail - remove;
          toRemove -= remove;
          if (xpState.fruitBag[emoji] === 0) delete xpState.fruitBag[emoji];
          if (toRemove === 0) break;
        }
      }
  // Add one higher rarity fruit
      let newFruit = getRandomFruitByRarity(toKey);
      if (!xpState.fruitBag[newFruit.emoji]) xpState.fruitBag[newFruit.emoji] = 0;
      xpState.fruitBag[newFruit.emoji]++;
      xpState.discoveredFruits[newFruit.emoji] = true; // <-- add this line
      saveXP();
      showXP();
      return `Traded up to <span style="font-size:1.2em">${newFruit.emoji}</span> <b>${newFruit.name}</b>!`;
    }
    document.getElementById('openTradeupMenu').onclick = function() {
      renderTradeupTiers(); // <-- this will render the fruit picker UI
      document.getElementById('tradeupModal').style.display = "flex";
    };
    document.getElementById('closeTradeupMenu').onclick = function() {
      document.getElementById('tradeupModal').style.display = "none";
    };
    // Optional: Close modal when background is clicked
    document.getElementById('tradeupModal').onclick = function(e) {
      if (e.target === this) this.style.display = "none";
    };
    function renderFruitEncyclopedia() {
      let html = '';
  // Group fruits by rarity for display
      let rarityOrder = ["Common", "Uncommon", "Rare", "Epic", "Legendary"];
      let rarityTitles = {
        Common: "üü¢ Common",
        Uncommon: "üîµ Uncommon",
        Rare: "üü£ Rare",
        Epic: "üü† Epic",
        Legendary: "üî¥ Legendary"
      };
      for (let rarity of rarityOrder) {
        let group = LEVELUP_REWARDS.filter(f => f.rarityKey === rarity);
        if (!group.length) continue;
        html += `<div style="margin:0.8em 0 0.2em 0; font-weight:bold;">${rarityTitles[rarity]}:</div>`;
        html += group.map(fruit => {
          let discovered = !!xpState.discoveredFruits[fruit.emoji];
          return `<span style="display:inline-block; min-width:3em; margin:0.18em 0.18em 0.45em 0.18em; text-align:center;">
            <span style="font-size:2em;">${discovered ? fruit.emoji : "‚ùì"}</span><br>
            <span style="font-size:0.96em; color:#333;">${discovered ? fruit.name : "???"}</span>
          </span>`;
        }).join('');
      }
      document.getElementById('fruitEncyclopediaBody').innerHTML = html;
    }
// Open/close handlers
    document.getElementById('openFruitEncyclopedia').onclick = function() {
      renderFruitEncyclopedia();
      document.getElementById('fruitEncyclopediaModal').style.display = "flex";
    };
    document.getElementById('closeFruitEncyclopedia').onclick = function() {
      document.getElementById('fruitEncyclopediaModal').style.display = "none";
    };
    // Optional: close when clicking background
    document.getElementById('fruitEncyclopediaModal').onclick = function(e) {
      if (e.target === this) this.style.display = "none";
    };
    function renderTradeupTiers() {
      const rarityOrder = ["Common","Uncommon","Rare","Epic"];
      const nextRarity = {
        Common: "Uncommon",
        Uncommon: "Rare",
        Rare: "Epic",
        Epic: "Legendary"
      };
      const cost = 5;
      let html = "";
      for (let from of rarityOrder) {
        let fromFruits = LEVELUP_REWARDS.filter(f => f.rarityKey === from);
        let to = nextRarity[from];
        if (!to) continue;
        let haveAny = fromFruits.some(fruit => (xpState.fruitBag[fruit.emoji]||0)>0);
        html += `<div style="margin:1em 0;">
          <b>${cost}√ó${fromFruits.map(f=>f.emoji).join("")} (${from}) ‚Üí 1√ó${LEVELUP_REWARDS.find(f=>f.rarityKey===to).emoji} (${to})</b><br>`;
        if (haveAny) {
          html += `<form class="tradeupForm" data-from="${from}" data-to="${to}">`;
          fromFruits.forEach(fruit => {
            let count = xpState.fruitBag[fruit.emoji]||0;
            html += `<span style="display:inline-block;margin:0.3em;">
              <span style="font-size:1.5em">${fruit.emoji}</span>
              <input type="number" min="0" max="${count}" value="0" style="width:3em;" name="${fruit.emoji}">
              <span style="font-size:0.9em;">/ ${count}</span>
            </span>`;
          });
          html += `<button type="submit">Trade Up</button></form>`;
        } else {
          html += `<span style="color:#888;">You have no ${from} fruits to trade up.</span>`;
        }
        html += `</div>`;
      }
      document.getElementById('tradeupTiers').innerHTML = html;

  // Add event listeners for all tradeup forms
      document.querySelectorAll('.tradeupForm').forEach(form => {
        form.onsubmit = function(e) {
          e.preventDefault();
          const from = form.getAttribute('data-from');
          const to = form.getAttribute('data-to');
          let total = 0;
          let useFruits = {};
          Array.from(form.elements).forEach(el => {
            if (el.tagName === "INPUT" && el.type === "number" && el.name) {
              let val = parseInt(el.value,10) || 0;
              if (val > 0) {
                useFruits[el.name] = val;
                total += val;
              }
            }
          });
          if (total !== cost) {
            document.getElementById('tradeupMsg').textContent = `You must select exactly ${cost} fruits to trade up.`;
            return;
          }
          document.getElementById('tradeupMsg').innerHTML = tryTradeUpSelected(from, to, cost, useFruits);
          renderTradeupTiers(); // re-render to update available counts
        };
      });
    }
    function tryTradeUpSelected(fromKey, toKey, cost, useFruits) {
  // Check counts
      let total = 0;
      for (let emoji in useFruits) {
        let count = xpState.fruitBag[emoji]||0;
        let use = useFruits[emoji];
        if (use > count) return `Not enough ${emoji} fruits!`;
        total += use;
      }
      if (total !== cost) return `You must select exactly ${cost} fruits.`;
  // Remove selected fruits
      for (let emoji in useFruits) {
        xpState.fruitBag[emoji] -= useFruits[emoji];
        if (xpState.fruitBag[emoji] <= 0) delete xpState.fruitBag[emoji];
      }
  // Add one higher rarity fruit
      let newFruit = getRandomFruitByRarity(toKey);
      if (!xpState.fruitBag[newFruit.emoji]) xpState.fruitBag[newFruit.emoji] = 0;
      xpState.fruitBag[newFruit.emoji]++;
      saveXP();
      showXP();
  // If encyclopedia modal open, update it
      if (document.getElementById('fruitEncyclopediaModal')?.style.display === "flex") renderFruitEncyclopedia();
      return `Traded up to <span style="font-size:1.2em">${newFruit.emoji}</span> <b>${newFruit.name}</b>!`;
    }
// --- Daily Challenge: 10 Questions, Retry on Failure ---
// --- Reset at midnight UTC+0 ---

// --- Daily Challenge State ---
let dailyChallengeState = JSON.parse(localStorage.getItem('dailyChallenge') || '{}');
function saveDailyChallenge() {
  localStorage.setItem('dailyChallenge', JSON.stringify(dailyChallengeState));
}

// --- Helper: get today's date string in UTC (YYYY-MM-DD) ---
function getTodayUTCDateString() {
  let d = new Date();
  return d.toISOString().slice(0, 10);
}

// --- Helper: seconds until next UTC midnight ---
function msUntilNextUTCMidnight() {
  let now = new Date();
  let nextMidnight = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0, 0));
  return nextMidnight - now;
}

// --- Get lock state for daily challenge (locked if already claimed today) ---
function getDailyChallengeLockState() {
  let today = getTodayUTCDateString();
  let locked = (dailyChallengeState.lastCompletedDate === today);
  let msLeft = locked ? msUntilNextUTCMidnight() : 0;
  return { locked, msLeft };
}

// --- Format ms as "Xh Ym Zs" ---
function formatCountdown(ms) {
  let s = Math.floor(ms / 1000);
  let h = Math.floor(s / 3600);
  let m = Math.floor((s % 3600) / 60);
  let sec = s % 60;
  return `${h}h ${m}m ${sec}s`;
}

// --- Generate a challenge question (your logic, unchanged) ---
function generateChallengeQuestion() {
  let eligible = pokedex.filter(poke => {
    let name = poke.speciesName;
    let fastList, chargeList;
    if (metaPreferred[name]) {
      fastList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
      chargeList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
    } else {
      fastList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
      chargeList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
    }
    return fastList.length && chargeList.length && metaPokes.includes(name);
  });
  if (!eligible.length) return null;
  let pokemon = eligible[Math.floor(Math.random() * eligible.length)];
  let name = pokemon.speciesName;
  let fastList = metaPreferred[name]
    ? [metaPreferred[name].fast].filter(mv => !!movesByName[mv])
    : (pokemon.fastMoves || []).filter(mv => !!movesByName[mv]);
  let chargeList = metaPreferred[name]
    ? [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv])
    : (pokemon.chargedMoves || []).filter(mv => !!movesByName[mv]);
  let fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
  let charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
  let which = 1 + Math.floor(Math.random() * 4);
  let nthText = getOrdinalText(which);
  let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
  return {
    question: `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`,
    answer: needed,
    fastMove: fast.Move,
    chargeMove: charge.Move,
    pokemon: pokemon.speciesName,
    fast,
    charge,
    poke: pokemon,
    which,
    nthText
  };
}

// --- Pick a reward fruit (Uncommon+) ---
function getDailyChallengeFruit() {
  const rarityTable = [
    { rarity: "Uncommon", prob: 45 },
    { rarity: "Rare",     prob: 35 },
    { rarity: "Epic",     prob: 15 },
    { rarity: "Legendary",prob: 5  }
  ];
  let r = Math.random() * 100, acc = 0, chosenRarity = "Uncommon";
  for (let row of rarityTable) {
    acc += row.prob;
    if (r < acc) { chosenRarity = row.rarity; break; }
  }
  const pool = LEVELUP_REWARDS.filter(f => f.rarityKey === chosenRarity);
  return pool[Math.floor(Math.random() * pool.length)];
}
function generateNewChallenge() {
  let questions = [];
  for (let i = 0; i < 10; ++i) {
    let q = generateChallengeQuestion();
    if (!q) break;
    questions.push(q);
  }
  let fruit = getDailyChallengeFruit();
  dailyChallengeState = {
    questions,
    progress: 0,
    failed: false,
    completed: false,
    fruit,
    fruitClaimed: false,
    lastCompletedDate: dailyChallengeState.lastCompletedDate || null
  };
  saveDailyChallenge();
  return dailyChallengeState;
}

// --- SESSION FLAG for "just completed" ---
let justCompletedDailyChallenge = false;

// --- Main render ---
function renderDailyChallenge() {
  let body = document.getElementById('dailyChallengeBody');
  let lock = getDailyChallengeLockState();
  let state = dailyChallengeState;

  // Show congrats/share if just completed (even if locked)
  if (state.fruitClaimed && (justCompletedDailyChallenge || !lock.locked)) {
    const shareMsg = `I completed today's Pok√©mon Go Moveset Energy Quiz Daily Challenge and got a ${state.fruit.emoji} ${state.fruit.name}! üçÄ
Try it yourself: https://aeeriis.github.io/GoMovesQuiz/
`;
    body.innerHTML =
      `üéâ <b>Complete!</b><br><br>
      You earned: <span style="font-size:2em">${state.fruit.emoji}</span> <b>${state.fruit.name}</b><br>
      <button id="dailyChallengeShareBtn" style="margin-top:1em;">Share</button>
      <div id="dailyChallengeShareMsg" style="color:#228be6;font-size:1em;margin-top:0.5em;"></div>
      <br>Come back after midnight UTC for a new challenge!`;

    const btn = document.getElementById('dailyChallengeShareBtn');
    const msgDiv = document.getElementById('dailyChallengeShareMsg');
    if (btn) {
      btn.onclick = async function () {
        if (navigator.share) {
          try {
            await navigator.share({ text: shareMsg });
            msgDiv.textContent = "Shared!";
          } catch (e) {
            msgDiv.textContent = "Share cancelled.";
          }
        } else {
          try {
            await navigator.clipboard.writeText(shareMsg);
            msgDiv.textContent = "Copied to clipboard!";
          } catch {
            msgDiv.textContent = "Failed to copy!";
          }
        }
        setTimeout(() => { msgDiv.textContent = ""; }, 2000);
      }
    }
    return;
  }

  // --- If locked, show countdown until midnight UTC ---
  if (lock.locked) {
    body.innerHTML =
      `‚è≥ <b>Come back after midnight UTC:</b><br><br>
      <span id="dailyChallengeCountdown" style="font-size:1.6em;"></span><br>
      <button id="dailyChallengeForceCheckBtn" style="margin-top:1em;">Check Again</button>`;
    function updateTimer() {
      let lock2 = getDailyChallengeLockState();
      document.getElementById('dailyChallengeCountdown').textContent = formatCountdown(lock2.msLeft);
      if (!lock2.locked) {
        renderDailyChallenge();
      } else {
        setTimeout(updateTimer, 1000);
      }
    }
    updateTimer();
    document.getElementById('dailyChallengeForceCheckBtn').onclick = renderDailyChallenge;
    return;
  }

  // --- If challenge failed ---
  if (state.failed) {
    body.innerHTML =
      `‚ùå <b>Challenge failed!</b><br><br>
      You missed a question.<br>
      <button id="dailyChallengeRetryBtn" style="margin-top:1em;">Try Again (New Questions)</button>`;
    document.getElementById('dailyChallengeRetryBtn').onclick = function() {
      generateNewChallenge();
      renderDailyChallenge();
    };
    return;
  }

  // --- If questions could not be generated ---
  if (!state.questions || state.questions.length !== 10) {
    body.innerHTML = "No eligible Pok√©mon for today's challenge.";
    return;
  }

  // --- During challenge ---
  let qNum = state.progress + 1;
  let q = state.questions[state.progress];
  body.innerHTML =
    `<div style="margin-bottom:0.5em;">Question ${qNum} of 10</div>
     <div style="margin-bottom:0.9em">${q.question}</div>
     <form id="dailyChallengeForm">
      <input type="number" id="dailyChallengeAnswer" min="1" required autocomplete="off" style="width:7em;font-size:1.2em;" />
      <button type="submit">Submit</button>
     </form>
     <div id="dailyChallengeResult" style="margin-top:0.7em; font-weight:bold;"></div>`;

  document.getElementById('dailyChallengeForm').onsubmit = function(e) {
    e.preventDefault();
    let ans = parseInt(document.getElementById('dailyChallengeAnswer').value, 10);
    let correct = (ans === q.answer);
    let resultDiv = document.getElementById('dailyChallengeResult');
    if (correct) {
      resultDiv.innerHTML = `‚úÖ Correct!`;
      state.progress++;
      if (state.progress === 10) {
        state.completed = true;
        state.fruitClaimed = true;
        state.lastCompletedDate = getTodayUTCDateString();
        justCompletedDailyChallenge = true;
        if (!xpState.fruitBag[state.fruit.emoji]) xpState.fruitBag[state.fruit.emoji] = 0;
        xpState.fruitBag[state.fruit.emoji]++;
        xpState.discoveredFruits[state.fruit.emoji] = true;
        if (typeof saveXP === "function") saveXP();
        if (typeof showXP === "function") showXP();
        if (typeof renderFruitEncyclopedia === "function") renderFruitEncyclopedia();
        saveDailyChallenge();
        renderDailyChallenge();
        return;
      }
      saveDailyChallenge();
      setTimeout(renderDailyChallenge, 500);
    } else {
      resultDiv.innerHTML = `‚ùå Incorrect. Challenge failed!`;
      state.failed = true;
      saveDailyChallenge();
      setTimeout(renderDailyChallenge, 800);
    }
  };
}

// --- Modal open handler ---
document.getElementById('openDailyChallenge').onclick = function() {
  let lock = getDailyChallengeLockState();
  justCompletedDailyChallenge = false;
  if (!lock.locked && (!dailyChallengeState.questions || dailyChallengeState.failed || dailyChallengeState.fruitClaimed)) {
    generateNewChallenge();
  }
  renderDailyChallenge();
  document.getElementById('dailyChallengeModal').style.display = "flex";
};
document.getElementById('closeDailyChallenge').onclick = function() {
  justCompletedDailyChallenge = false;
  document.getElementById('dailyChallengeModal').style.display = "none";
};
document.getElementById('dailyChallengeModal').onclick = function(e) {
  if (e.target === this) {
    justCompletedDailyChallenge = false;
    this.style.display = "none";
  }
};
// feedback
const openFeedback = document.getElementById('openFeedback');
const feedbackModal = document.getElementById('feedbackModal');
const closeFeedbackModal = document.getElementById('closeFeedbackModal');
const feedbackForm = document.getElementById('feedbackForm');
const feedbackText = document.getElementById('feedbackText');
const feedbackThanks = document.getElementById('feedbackThanks');

openFeedback.onclick = () => {
  feedbackModal.style.display = 'flex';
  feedbackThanks.style.display = 'none';
  feedbackForm.style.display = 'flex';
  feedbackText.value = '';
};
closeFeedbackModal.onclick = () => {
  feedbackModal.style.display = 'none';
};
feedbackForm.onsubmit = (e) => {
  e.preventDefault();
  // Send feedback via email (mailto)
  const body = encodeURIComponent(feedbackText.value);
  window.open(`mailto:aeeriis1@gmail.com?subject=GoMovesQuiz%20Feedback&body=${body}`, '_blank');
  feedbackForm.style.display = 'none';
  feedbackThanks.style.display = 'block';
  setTimeout(() => {
    feedbackModal.style.display = 'none';
  }, 2000);
};
  </script>
</body>
</html>
