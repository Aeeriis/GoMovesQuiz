<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pokémon Go Moveset Energy Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="manifest" href="manifest.json">
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #fafaff; }
    .container { max-width: 480px; margin: auto; padding: 1em; }
    .disclaimer {
      font-size: 0.98em;
      color: #505050;
      background: #eef3ff;
      border-radius: 8px;
      padding: 0.7em 1em;
      margin-bottom: 1.2em;
      margin-top: 0.7em;
      text-align: center;
      border: 1px solid #d0d8e8;
    }
    .copyright {
      font-size: 0.83em;
      color: #666;
      text-align: center;
      margin-top: 2.3em;
      margin-bottom: 0.7em;
      padding: 0 0.6em;
      line-height: 1.5;
    }
    h1 { font-size: 1.6em; }
    .quiz-section { margin-top: 2em; }
    .result { margin-top: 1em; font-weight: bold; }
    input[type="number"] { width: 90%; font-size: 1.2em; }
    button { font-size: 1.1em; padding: 0.6em 1.2em; margin-top: 1em;}
    label { font-size: 1.1em; }
    #question { font-size: 1.15em; margin-bottom: 1em; }
    #stats { font-size: 1.1em; margin: 0.8em 0; }
    #avgstats { font-size: 1em; margin: 0.2em 0 0.8em 0; color: #234;}
    #difficultySelect, #timerToggle { font-size: 1em; margin-bottom: 1em;}
    #difficultyWrap { margin-bottom: 0.2em; }
    #metaSettingsWrap {
      margin: 1.2em 0 0.5em 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #metaBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.4em;
      display: flex;
      align-items: center;
      gap: 1.3em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
      flex-wrap: wrap;
    }
    #metaSelect {
      font-size: 1em;
      margin-right: 1.2em;
    }
    #metaToggleWrap {
      display: flex;
      flex-wrap: wrap;
      gap: 1.1em;
      margin-bottom: 0.15em;
      margin-left: 0.1em;
      margin-top: 0.12em;
      align-items: center;
    }
    #metaScoreLabel, #metaPrefLabel, #noTrickLabel {
      font-size: 0.97em;
      font-weight: bold;
      user-select: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 0;
      padding: 0;
    }
    #metaScore, #metaPref, #noTrick {
      vertical-align: middle;
      margin-right: 0.4em;
      accent-color: #228be6;
    }
    #metaScoreExplain, #metaPrefExplain, #noTrickExplain {
      font-size: 0.93em;
      color: #234;
      margin-top: 0.15em;
      margin-bottom: 0.13em;
      line-height: 1.35;
      padding-left: 0.1em;
    }
    #intro-explanation { margin: 1.1em 0 0.7em 0; background: #f0f7ff; border-radius: 8px; padding: 0.8em; font-size: 1.07em; color: #234; }
    #fixedNextWrap {
      display: none;
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: transparent;
      z-index: 100;
      text-align: center;
      pointer-events: none;
    }
    #fixedNextWrap.show {
      display: block;
    }
    #fixedNextBtn {
      font-size: 1.18em;
      padding: 0.75em 2.2em;
      background: #fff;
      color: #228be6;
      border: 2.5px solid #228be6;
      border-radius: 32px;
      box-shadow: 0 2px 14px #228be644, 0 1.5px 0 #eee inset;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2.5em;
      pointer-events: auto;
      transition: background .18s, color .18s, border .18s;
      position: relative;
    }
    #fixedNextBtn:hover, #fixedNextBtn:focus {
      background: #228be6;
      color: #fff;
      border-color: #228be6;
      outline: none;
    }
    #fixedNextBtn:active {
      background: #1864ab;
      color: #fff;
      border-color: #1864ab;
    }
    #fixedNextBtnWrap {
      display: inline-block;
      position: relative;
    }
    #timerSettingsWrap {
      margin-bottom: 1em;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #timerBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.8em;
      display: flex;
      align-items: center;
      gap: 1.2em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
    }
    #timer {
      min-width: 7em;
      font-weight: bold;
      display: inline-block;
      text-align: left;
      visibility: hidden;
      transition: opacity 0.2s;
    }
    .timer-visible {
      visibility: visible !important;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 28px;
      vertical-align: middle;
      margin-right: 0.5em;
      flex-shrink: 0;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .3s;
      border-radius: 34px;
      border: 2.5px solid #bbb;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 2.7px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px #0001;
    }
    input:checked + .slider {
      background-color: #228be6;
      border-color: #228be6;
    }
    input:checked + .slider:before {
      transform: translateX(17px);
    }
    #timerToggleLabel {
      font-size: 1.07em;
      user-select: none;
      cursor: pointer;
      font-weight: bold;
      display: flex;
      align-items: center;
      margin-left: 0em;
      margin-top: 0.33em;
    }
    #levelBox {
      margin: 1em 0 0.8em 0;
      font-size: 1.10em;
      color: #234;
      background: #f4fafe;
      border-radius: 10px;
      padding: 0.7em 1.1em 0.8em 1.1em;
      border: 1.5px solid #bee3f8;
      display: inline-block;
      min-width: 200px;
      position: relative;
      box-shadow: 0 2px 10px #228be611;
    }
    #levelXPBar {
      width: 100%;
      background: #d0e6fa;
      border-radius: 6px;
      height: 18px;
      margin-top: 0.5em;
      position: relative;
      overflow: hidden;
    }
    #levelXPBarInner {
      background: linear-gradient(90deg,#228be6,#63c2ff);
      height: 100%;
      border-radius: 6px;
      transition: width 0.5s cubic-bezier(.4,2,.3,1);
      width: 0%;
      min-width: 2.5%;
    }
    #levelUPMsg {
      color: #f4930c;
      font-weight: bold;
      font-size: 1.08em;
      margin: 0.2em 0 0 0;
      display: none;
      animation: pop-in 0.85s cubic-bezier(.4,2,.3,1);
    }
    @keyframes pop-in {
      0% { transform: scale(1.6); opacity: 0; }
      30% { transform: scale(1.13); opacity: 1;}
      60% { transform: scale(0.97);}
      80% { transform: scale(1.03);}
      100% { transform: scale(1); opacity: 1;}
    }
    @media (max-width: 600px) {
      h1 { font-size: 1.2em; }
      .container { padding: 0.5em; }
      #intro-explanation { font-size: 0.97em; }
      #fixedNextBtn { font-size: 1em; padding: 0.7em 1.5em; }
      #fixedNextWrap { padding-bottom: 0em; }
      #timerBox { font-size: 1em; gap: 0.7em; }
      #timerToggleLabel { font-size: 1em; }
      #fixedNextBtn { margin-bottom: 2em; }
      #metaBox {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.3em;
      }
      #metaToggleWrap {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35em;
        margin-bottom: 0.2em;
        margin-left: 0;
      }
      #metaScoreExplain, #metaPrefExplain, #noTrickExplain { font-size: 0.88em; padding-left: 0.3em; }
      .disclaimer { font-size: 0.95em; padding: 0.56em 0.7em; }
      .copyright { font-size: 0.78em; }
    }
  </style>
  <script type="module">
    // ---- XP/LEVEL SYSTEM ----
    function getLevelAndNextXP(xp) {
      let thresholds = [0];
      for(let lvl=1, req=100; lvl<100; ++lvl) {
        thresholds[lvl] = thresholds[lvl-1] + req;
        req += 50;
        if (thresholds[lvl] > 1000000) break;
      }
      let level = 1;
      for(let i=1; i<thresholds.length; ++i) {
        if (xp < thresholds[i]) break;
        level = i+1;
      }
      let prev = thresholds[level-2]||0, next = thresholds[level-1]||100;
      return { level, prev, next };
    }
    function getXPForAnswer(isCorrect, elapsed, difficulty, score80) {
      // XP reward table (per spec)
      let xpCorrect, xpIncorrect, xpSpeed;
      if (difficulty === "basic") {
        xpCorrect = score80 ? 5 : 8;
        xpIncorrect = score80 ? 1 : 2;
        xpSpeed = score80 ? 2 : 3;
      } else if (difficulty === "multi") {
        xpCorrect = score80 ? 8 : 12;
        xpIncorrect = score80 ? 2 : 3;
        xpSpeed = score80 ? 3 : 5;
      } else { // combo
        xpCorrect = score80 ? 12 : 18;
        xpIncorrect = score80 ? 3 : 5;
        xpSpeed = score80 ? 4 : 7;
      }
      let xp = isCorrect ? xpCorrect : xpIncorrect;
      if (isCorrect && typeof elapsed === "number" && elapsed > 0 && elapsed < 5) xp += xpSpeed;
      return xp;
    }
    function animateXPBar(fromXP, toXP, levelDataFrom, levelDataTo) {
      const bar = document.getElementById('levelXPBarInner');
      const xpText = document.getElementById('levelXPText');
      let start = null, duration = 600;
      let fromLevel = levelDataFrom.level, toLevel = levelDataTo.level;
      let fromFrac = (fromXP-levelDataFrom.prev)/(levelDataFrom.next-levelDataFrom.prev);
      let toFrac = (toXP-levelDataTo.prev)/(levelDataTo.next-levelDataTo.prev);
      function step(ts) {
        if (!start) start = ts;
        let t = Math.min((ts-start)/duration, 1);
        let curFrac = fromFrac + (toFrac-fromFrac)*t;
        let curLevel = fromLevel + (toLevel-fromLevel)*t;
        if (toLevel !== fromLevel && t > 0.6) {
          document.getElementById('levelUPMsg').style.display = "block";
        }
        let curXP = Math.round(fromXP + (toXP-fromXP)*t);
        bar.style.width = (100*curFrac).toFixed(1)+"%";
        xpText.textContent = `XP: ${curXP} / ${levelDataTo.next}`;
        if (t < 1) requestAnimationFrame(step);
        else setTimeout(()=>{document.getElementById('levelUPMsg').style.display="none";}, 1600);
      }
      requestAnimationFrame(step);
    }
    function setLevelUI(xp) {
      const {level, prev, next} = getLevelAndNextXP(xp);
      document.getElementById('levelNum').textContent = level;
      document.getElementById('levelXPText').textContent = `XP: ${xp} / ${next}`;
      const frac = (xp-prev)/(next-prev);
      document.getElementById('levelXPBarInner').style.width = (100*frac).toFixed(1)+"%";
      document.getElementById('levelUPMsg').style.display = "none";
    }
    // ---- END XP/LEVEL SYSTEM ----

    window.addEventListener('DOMContentLoaded', () => {
      // --- STATS (localStorage) ---
      let stats = {
        total: 0, correct: 0, sumTime: 0, sumTimeRight: 0, rightCount: 0, xp: 0
      };
      function loadStats() {
        try {
          let s = JSON.parse(localStorage.getItem("quizStats") || "{}");
          stats = Object.assign({
            total: 0, correct: 0, sumTime: 0, sumTimeRight: 0, rightCount: 0, xp: 0
          }, s);
        } catch(e) { /* ignore */ }
        showStats();
      }
      function saveStats() {
        localStorage.setItem("quizStats", JSON.stringify(stats));
      }
      function showStats() {
        document.getElementById('stats').textContent =
          `Score: ${stats.correct}/${stats.total} (${stats.total ? Math.round(100 * stats.correct / stats.total) : 0}%)`;
        let avg = stats.total ? (stats.sumTime / stats.total) : 0;
        let avgRight = stats.rightCount ? (stats.sumTimeRight / stats.rightCount) : 0;
        document.getElementById('avgstats').textContent =
          `Average time: ${stats.total ? avg.toFixed(2) + " s" : "-"}   |   Average for correct: ${stats.rightCount ? avgRight.toFixed(2) + " s" : "-"}`;
        setLevelUI(stats.xp || 0);
      }
      document.getElementById('resetStats').onclick = function() {
        stats = { total: 0, correct: 0, sumTime: 0, sumTimeRight: 0, rightCount: 0, xp: 0 };
        saveStats();
        showStats();
      };

      // ---- QUIZ LOGIC (unchanged, except XP/level) ----
      // Meta CSVs
      const metaCSVFILES = [
        { file: "cp1500_all_overall_rankings.csv", label: "Great" },
        { file: "cp2500_all_overall_rankings.csv", label: "Ultra" },
        { file: "cp10000_all_overall_rankings.csv", label: "Master" },
        { file: "cp10000_premier_overall_rankings.csv", label: "Master Premier" },
        { file: "cp1500_tempo_overall_rankings.csv", label: "Tempo" },
        { file: "cp1500_wasteland_overall_rankings.csv", label: "Wasteland" },
        { file: "cp2500_battlefrontierultra_overall_rankings.csv", label: "Battlefrontier Ultra" },
        { file: "cp10000_battlefrontiermaster_overall_rankings.csv", label: "Battlefrontier Master" },
        { file: "cp1500_gbinvitational_overall_rankings.csv", label: "Gymbreakers Invitational" },
        { file: "cp1500_rivalry_overall_rankings.csv", label: "Rivalry" },
        { file: "cp1500_catch_overall_rankings.csv", label: "Catch Cup" }
      ];
      const githubUser = "Aeeriis";
      const githubRepo = "GoMovesQuiz";
      const metaRootURL = `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/main/rankings/`;

      let metaPokes = [];
      let metaPreferred = {};
      let currentMeta = localStorage.getItem("quizMeta") || metaCSVFILES[0].file;
      let onlyHighScore = localStorage.getItem("onlyHighScore") === "true";
      let onlyPreferredMoveset = localStorage.getItem("onlyPreferredMoveset") === "true";
      let avoidTrickQuestions = localStorage.getItem("avoidTrickQuestions") === "true";

      function populateMetaMenu() {
        const metaSelect = document.getElementById('metaSelect');
        metaSelect.innerHTML = "";
        metaCSVFILES.forEach(meta => {
          let opt = document.createElement("option");
          opt.value = meta.file;
          opt.textContent = meta.label;
          metaSelect.appendChild(opt);
        });
        metaSelect.value = currentMeta;
        document.getElementById('metaScore').checked = onlyHighScore;
        document.getElementById('metaPref').checked = onlyPreferredMoveset;
        document.getElementById('noTrick').checked = avoidTrickQuestions;
        loadMetaAndApply();
      }
      document.getElementById('metaSelect').onchange = function() {
        currentMeta = this.value;
        localStorage.setItem("quizMeta", currentMeta);
        loadMetaAndApply();
      };
      document.getElementById('metaScore').onchange = function() {
        onlyHighScore = this.checked;
        localStorage.setItem("onlyHighScore", onlyHighScore);
        loadMetaAndApply();
      };
      document.getElementById('metaPref').onchange = function() {
        onlyPreferredMoveset = this.checked;
        localStorage.setItem("onlyPreferredMoveset", onlyPreferredMoveset);
        loadMetaAndApply();
      };
      document.getElementById('noTrick').onchange = function() {
        avoidTrickQuestions = this.checked;
        localStorage.setItem("avoidTrickQuestions", avoidTrickQuestions);
        loadMetaAndApply();
      };

      function loadMetaAndApply() {
        document.getElementById('metaWarn').textContent = "";
        metaPreferred = {};
        if (!currentMeta) { metaPokes = []; return; }
        fetch(metaRootURL + encodeURIComponent(currentMeta))
          .then(r => r.text())
          .then(csv => {
            const lines = csv.trim().split(/\r?\n/);
            if (lines.length < 2) {
              metaPokes = [];
              document.getElementById('metaWarn').textContent = "No Pokémon found for this meta.";
              return;
            }
            const head = lines[0].split(",");
            const idxName = head.findIndex(h => h.trim().toLowerCase() === "pokemon");
            const idxScore = head.findIndex(h => h.trim().toLowerCase() === "score");
            const idxFM = head.findIndex(h => h.trim().toLowerCase() === "fast move");
            const idxC1 = head.findIndex(h => h.trim().toLowerCase() === "charged move 1");
            const idxC2 = head.findIndex(h => h.trim().toLowerCase() === "charged move 2");
            if (idxName === -1 || idxScore === -1) {
              metaPokes = [];
              document.getElementById('metaWarn').textContent = "Meta CSV missing Pokemon or Score column.";
              return;
            }
            metaPokes = [];
            metaPreferred = {};
            lines.slice(1).forEach(rowstr => {
              const row = rowstr.split(",");
              const name = row[idxName];
              const score = parseFloat(row[idxScore]);
              if (!onlyHighScore || score > 80) {
                metaPokes.push(name);
              }
              if (idxFM !== -1 && idxC1 !== -1 && idxC2 !== -1) {
                metaPreferred[name] = {
                  fast: row[idxFM],
                  charge1: row[idxC1],
                  charge2: row[idxC2]
                };
              }
            });
            if (!metaPokes.length) {
              document.getElementById('metaWarn').textContent = "No Pokémon with Score > 80 in this meta.";
            }
            newQuestion();
          });
      }

      function isTrickCombo(fastEnergy, chargeEnergy) {
        if (!fastEnergy || !chargeEnergy) return false;
        return (chargeEnergy % fastEnergy === 0);
      }

      // Timer logic
      let timerStart = null, timerInterval = null, timerActive = false;
      const timerSpan = document.getElementById('timer');
      const timerBox = document.getElementById('timerBox');
      const timerToggle = document.getElementById('timerToggle');
      const timerToggleLabel = document.getElementById('timerToggleLabel');
      let timerEnabled = localStorage.getItem('timerEnabled');
      if (timerEnabled === null) timerEnabled = "true";
      timerEnabled = timerEnabled === "true";
      timerToggle.checked = timerEnabled;
      function updateTimerVisibilityOnQuestion() {
        timerSpan.classList.remove('timer-visible');
        timerSpan.textContent = "";
      }
      function updateTimerVisibilityOnAnswer(timeText) {
        if (timerEnabled && timeText) {
          timerSpan.textContent = timeText;
          timerSpan.classList.add('timer-visible');
        } else {
          timerSpan.classList.remove('timer-visible');
          timerSpan.textContent = "";
        }
      }
      timerToggle.onchange = function() {
        timerEnabled = timerToggle.checked;
        localStorage.setItem('timerEnabled', timerEnabled ? "true" : "false");
        if (!timerEnabled) updateTimerVisibilityOnAnswer();
      };
      function startTimer() {
        timerStart = Date.now();
        timerActive = true;
        timerSpan.classList.remove('timer-visible');
        timerSpan.textContent = "";
        if (timerInterval) clearInterval(timerInterval);
      }
      function stopTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = null;
        timerActive = false;
      }
      function getTimerElapsed() {
        if (!timerStart) return 0;
        return (Date.now() - timerStart) / 1000;
      }
      // Difficulty logic
      let difficulty = localStorage.getItem("quizDifficulty") || "multi";
      document.getElementById('difficultySelect').value = difficulty;
      document.getElementById('difficultySelect').onchange = function() {
        difficulty = this.value;
        localStorage.setItem("quizDifficulty", difficulty);
        newQuestion();
      };

      function getOrdinalText(n) {
        return ["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th"][n-1] || (n+"th");
      }
      function getExplanation(pair) {
        let fastName = pair.fast.Move;
        let fastEnergy = pair.fast.Energy;
        if (pair.isCombo) {
          let chargeA = pair.combo.chargeA, nA = pair.combo.nA, chargeB = pair.charge;
          let explanation =
            `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
            `First, ${nA} <b>${chargeA.Move}</b> (Charged) are used. Each costs <b>${chargeA.Energy}</b> energy.<br>`;
          let log = [];
          let energy = 0, totalFasts = 0;
          for (let i=1; i<=nA; ++i) {
            let thisFasts = 0, startEnergy = energy;
            let movesSoFar = [];
            while (energy < chargeA.Energy) {
              energy += fastEnergy;
              totalFasts++;
              thisFasts++;
              movesSoFar.push(startEnergy + thisFasts * fastEnergy);
            }
            log.push(`For the ${getOrdinalText(i)} ${chargeA.Move}:<br>` +
              `&nbsp;&nbsp;Start with <b>${startEnergy}</b> energy.<br>` +
              `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
              `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startEnergy + thisFasts * fastEnergy}</b> energy (≥ ${chargeA.Energy} needed).<br>` +
              `&nbsp;&nbsp;You spend ${chargeA.Energy} for the charged move, leaving <b>${startEnergy + thisFasts*fastEnergy - chargeA.Energy}</b> energy for the next.<br>`
            );
            energy -= chargeA.Energy;
          }
          let beforeB = energy;
          let fastsForB = 0, breakdownB = [];
          let energyB = beforeB;
          while (energyB < chargeB.Energy) {
            energyB += fastEnergy;
            fastsForB++;
            breakdownB.push(beforeB + fastsForB * fastEnergy);
          }
          explanation += log.join('<br>') + `<br>After those, you have <b>${beforeB}</b> energy.<br>`;
          explanation += `Each fast attack gives <b>${fastEnergy}</b> energy: <b>${breakdownB.join(', ')}</b>.<br>`;
          explanation += `After ${fastsForB} fast attacks you have <b>${beforeB + fastsForB*fastEnergy}</b> energy (≥ ${chargeB.Energy} needed).<br>`;
          explanation += `You spend ${chargeB.Energy} for the charged move, leaving <b>${beforeB + fastsForB*fastEnergy - chargeB.Energy}</b> energy for the next.<br>`;
          return explanation;
        } else {
          let chargeName = pair.charge.Move;
          let chargeEnergy = pair.charge.Energy;
          let n = pair.which;
          let explanation = 
            `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
            `You need <b>${chargeEnergy}</b> energy for each <b>${chargeName}</b> (Charged).<br>`;
          let breakdown = [];
          let energy = 0;
          for (let i = 1; i <= n; i++) {
            let thisFasts = 0;
            let startingEnergy = energy;
            let movesSoFar = [];
            while (energy < chargeEnergy) {
              energy += fastEnergy;
              thisFasts++;
              movesSoFar.push(startingEnergy + thisFasts * fastEnergy);
            }
            breakdown.push(
              `For the ${getOrdinalText(i)} charged move:<br>` +
              `&nbsp;&nbsp;Start with <b>${startingEnergy}</b> energy.<br>` +
              `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
              `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startingEnergy + thisFasts*fastEnergy}</b> energy (≥ ${chargeEnergy} needed).<br>` +
              `&nbsp;&nbsp;You spend ${chargeEnergy} for the charged move, leaving <b>${startingEnergy + thisFasts*fastEnergy - chargeEnergy}</b> energy for the next.<br>`
            );
            energy -= chargeEnergy;
          }
          explanation += breakdown.join('<br>');
          return explanation;
        }
      }
      let moves = [], movesByName = {}, pokedex = [], currentPair = {};

      Promise.all([
        fetch('moves.csv').then(r => r.text()),
        fetch('pokemon.json').then(r => r.json())
      ]).then(([csvData, pokeData]) => {
        moves = parseCSV(csvData);
        movesByName = {};
        moves.forEach(mv => {
          movesByName[mv.Move.trim().toUpperCase().replace(/ /g, "_")] = mv;
          movesByName[mv.Move.trim()] = mv;
        });
        pokedex = pokeData;
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('quizSection').classList.remove('hidden');
        loadStats();
        populateMetaMenu();
      });

      function parseCSV(data) {
        const lines = data.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        return lines.slice(1).map(line => {
          let cells = [], cell = '', inQuotes = false;
          for (let ch of line) {
            if (ch === '"') inQuotes = !inQuotes;
            else if (ch === ',' && !inQuotes) { cells.push(cell); cell = ''; }
            else cell += ch;
          }
          cells.push(cell);
          let obj = {};
          headers.forEach((h, i) => {
            obj[h] = cells[i] !== undefined ? cells[i].trim() : '';
            if (['Energy'].includes(h)) {
              obj[h] = obj[h] === '' ? NaN : parseInt(obj[h], 10);
            }
          });
          return obj;
        });
      }

      function pickEligiblePokemon() {
        let eligible = pokedex.filter(poke => {
          let name = poke.speciesName;
          let fastList, chargeList;
          if (onlyPreferredMoveset && metaPreferred[name]) {
            fastList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
            chargeList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
          } else {
            fastList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
            chargeList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
          }
          return fastList.length && chargeList.length && (!metaPokes.length || metaPokes.includes(name));
        });
        if (!eligible.length) return null;
        return eligible[Math.floor(Math.random() * eligible.length)];
      }

      function getPreferredOrAllFastMoves(poke) {
        let name = poke.speciesName;
        if (onlyPreferredMoveset && metaPreferred[name]) {
          let fm = metaPreferred[name].fast;
          return [fm].filter(mv => !!movesByName[mv]);
        }
        return (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
      }
      function getPreferredOrAllChargeMoves(poke) {
        let name = poke.speciesName;
        if (onlyPreferredMoveset && metaPreferred[name]) {
          let c1 = metaPreferred[name].charge1;
          let c2 = metaPreferred[name].charge2;
          return [c1, c2].filter((mv, i, arr) => mv && arr.indexOf(mv) === i && !!movesByName[mv]);
        }
        return (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
      }

      function calcFastMovesForNthCharge(fastEnergy, chargeEnergy, n) {
        let energy = 0;
        let fastsToEachCharge = [];
        for(let i=1; i<=n; ++i) {
          let thisChargeFasts = 0;
          while (energy < chargeEnergy) {
            energy += fastEnergy;
            thisChargeFasts++;
          }
          energy -= chargeEnergy;
          fastsToEachCharge.push(thisChargeFasts);
        }
        return fastsToEachCharge[n-1];
      }
      function newQuestion() {
        document.getElementById('result').textContent = '';
        document.getElementById('nextQuestion').classList.add('hidden');
        document.getElementById('userAnswer').value = '';
        showFixedNextButton(false);
        stopTimer();
        updateTimerVisibilityOnQuestion();
        if (!metaPokes.length) {
          document.getElementById('question').textContent = "No eligible Pokémon for this meta and filter.";
          document.getElementById('answerForm').classList.add('hidden');
          return;
        }
        // --- BASIC ---
        if (difficulty === "basic") {
          let tries = 0, pokemon, fastList, chargeList, fast, charge;
          do {
            pokemon = pickEligiblePokemon();
            if (!pokemon) break;
            fastList = getPreferredOrAllFastMoves(pokemon);
            chargeList = getPreferredOrAllChargeMoves(pokemon);
            fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
            charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
            tries++;
          } while (
            avoidTrickQuestions &&
            isTrickCombo(fast.Energy, charge.Energy) &&
            tries < 30
          );
          if (!pokemon) {
            document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
            document.getElementById('answerForm').classList.add('hidden');
            return;
          }
          let which = 1;
          let nthText = getOrdinalText(which);
          let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
          currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
          document.getElementById('question').textContent =
            `How many "${fast.Move}" (Fast) are needed for the 1st "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
          document.getElementById('answerForm').classList.remove('hidden');
          startTimer();
          return;
        }
        // --- COMBO ---
        if (difficulty === "combo") {
          if (Math.random() < 1/3) {
            let tries = 0, pokemon, fastList, chargeList, chargeAIdx, chargeBIdx, fast, chargeA, chargeB;
            do {
              let eligible = pokedex.filter(poke => {
                let name = poke.speciesName;
                let fList, cList;
                if (onlyPreferredMoveset && metaPreferred[name]) {
                  fList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
                  cList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
                } else {
                  fList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
                  cList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
                }
                return fList.length && cList.length >= 2 && (!metaPokes.length || metaPokes.includes(name));
              });
              if (!eligible.length) break;
              pokemon = eligible[Math.floor(Math.random() * eligible.length)];
              fastList = getPreferredOrAllFastMoves(pokemon);
              chargeList = getPreferredOrAllChargeMoves(pokemon);
              chargeAIdx = Math.floor(Math.random() * chargeList.length);
              do { chargeBIdx = Math.floor(Math.random() * chargeList.length); } while (chargeBIdx === chargeAIdx);
              fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
              chargeA = movesByName[chargeList[chargeAIdx]];
              chargeB = movesByName[chargeList[chargeBIdx]];
              tries++;
            } while (
              avoidTrickQuestions &&
              isTrickCombo(fast.Energy, chargeA.Energy) &&
              isTrickCombo(fast.Energy, chargeB.Energy) &&
              tries < 30
            );
            if (!pokemon) return newQuestion();
            let nA = 1 + Math.floor(Math.random() * 3);
            let energy = 0, totalFasts = 0;
            for (let i=0; i<nA; ++i) {
              while (energy < chargeA.Energy) {
                energy += fast.Energy;
                totalFasts++;
              }
              energy -= chargeA.Energy;
            }
            let neededFastsForB = 0;
            let currentEnergy = energy;
            while (currentEnergy < chargeB.Energy) {
              currentEnergy += fast.Energy;
              neededFastsForB++;
            }
            currentPair = {
              fast, charge: chargeB, pokemon, needed: neededFastsForB, isCombo: true,
              combo: { chargeA, nA, leftover: energy }
            };
            document.getElementById('question').textContent =
              `${pokemon.speciesName} with ${fast.Move} (Fast) has thrown ${nA} ${chargeA.Move} (Charged).` +
              ` How many more ${fast.Move} are needed for a ${chargeB.Move} (Charged) now?`;
            document.getElementById('answerForm').classList.remove('hidden');
            startTimer();
            return;
          } else {
            let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
            do {
              pokemon = pickEligiblePokemon();
              if (!pokemon) break;
              fastList = getPreferredOrAllFastMoves(pokemon);
              chargeList = getPreferredOrAllChargeMoves(pokemon);
              fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
              charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
              which = 1 + Math.floor(Math.random() * 4);
              tries++;
            } while (
              avoidTrickQuestions &&
              isTrickCombo(fast.Energy, charge.Energy) &&
              which > 1 &&
              tries < 30
            );
            if (!pokemon) {
              document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
              document.getElementById('answerForm').classList.add('hidden');
              return;
            }
            let nthText = getOrdinalText(which);
            let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
            currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
            document.getElementById('question').textContent =
              `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
            document.getElementById('answerForm').classList.remove('hidden');
            startTimer();
            return;
          }
        }
        // --- MULTI-CHARGE ---
        let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
        do {
          pokemon = pickEligiblePokemon();
          if (!pokemon) break;
          fastList = getPreferredOrAllFastMoves(pokemon);
          chargeList = getPreferredOrAllChargeMoves(pokemon);
          fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
          charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
          which = 1 + Math.floor(Math.random() * 4);
          tries++;
        } while (
          avoidTrickQuestions &&
          isTrickCombo(fast.Energy, charge.Energy) &&
          which > 1 &&
          tries < 30
        );
        if (!pokemon) {
          document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
          document.getElementById('answerForm').classList.add('hidden');
          return;
        }
        let nthText = getOrdinalText(which);
        let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
        currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
        document.getElementById('question').textContent =
          `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
        document.getElementById('answerForm').classList.remove('hidden');
        startTimer();
      }
      document.getElementById('answerForm').addEventListener('submit', function(e) {
        e.preventDefault();
        stopTimer();
        const userAnswer = parseInt(document.getElementById('userAnswer').value, 10);
        let wasCorrect = false;
        if (userAnswer === currentPair.needed) {
          document.getElementById('result').textContent = '✅ Correct!';
          wasCorrect = true;
        } else {
          document.getElementById('result').textContent =
            `❌ Incorrect. The correct answer is ${currentPair.needed}.`;
        }
        let timeText = "";
        let elapsed = 0;
        if (timerEnabled && typeof timerStart === "number" && timerStart > 0) {
          elapsed = getTimerElapsed();
          timeText = "Answered in " + elapsed.toFixed(2) + " s";
        }
        // XP/Level logic
        let oldXP = stats.xp || 0;
        // OnlyHighScore == Score>80 filter
        let xpGain = getXPForAnswer(wasCorrect, elapsed, difficulty, onlyHighScore);
        stats.xp = (stats.xp||0) + xpGain;
        let from = getLevelAndNextXP(oldXP);
        let to = getLevelAndNextXP(stats.xp);
        animateXPBar(oldXP, stats.xp, from, to);

        stats.total = (stats.total || 0) + 1;
        stats.sumTime = (stats.sumTime || 0) + (elapsed || 0);
        if (wasCorrect) {
          stats.correct = (stats.correct || 0) + 1;
          stats.sumTimeRight = (stats.sumTimeRight || 0) + (elapsed || 0);
          stats.rightCount = (stats.rightCount || 0) + 1;
        }
        saveStats();
        showStats();
        updateTimerVisibilityOnAnswer(timeText);
        if (timerEnabled && timeText) {
          document.getElementById('result').innerHTML +=
            `<br><span style="color:#228be6;font-weight:bold;">${timeText}</span>`;
        }
        document.getElementById('result').innerHTML +=
          "<br><span style='font-size:0.95em;color:#555;'>" + getExplanation(currentPair) + "</span>" +
          `<br><span style="color:#23a;font-size:1em;font-weight:bold;">+${xpGain} XP</span>`;
        showFixedNextButton(true);
      });

      // Floating Next Button logic
      const fixedNextWrap = document.getElementById('fixedNextWrap');
      const fixedNextBtn = document.getElementById('fixedNextBtn');
      function showFixedNextButton(show) {
        if (show) fixedNextWrap.classList.add('show');
        else fixedNextWrap.classList.remove('show');
      }
      fixedNextBtn.onclick = function() {
        showFixedNextButton(false);
        newQuestion();
      };
      document.getElementById('nextQuestion').style.display = "none";
      // ---- END QUIZ LOGIC ----
    });
  </script>
</head>
<body>
  <div class="container">
    <div class="disclaimer">
      <b>Disclaimer:</b> This entire app was created by AI (GitHub Copilot). All gameplay and meta data used here are from <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a>.
    </div>
    <h1>Pokémon Go Moveset Energy Quiz</h1>
    <div id="levelBox">
      <span style="font-weight:bold;">Level <span id="levelNum">1</span></span>
      <br>
      <span id="levelXPText">XP: 0 / 100</span>
      <div id="levelXPBar"><div id="levelXPBarInner"></div></div>
      <div id="levelUPMsg">Level Up!</div>
    </div>
    <div id="intro-explanation">
      <b>How the quiz works:</b>
      <ul>
        <li><b>Basic</b> – How many fast moves do you need for the <u>first</u> charged move?</li>
        <li><b>Multi-Charge</b> – How many fast moves do you need for the <u>1st, 2nd, 3rd, or 4th</u> charged move?</li>
        <li><b>Combo</b> – After using a certain number of one charged move, how many fast moves are needed for a different charged move? (Combo mode now also includes Multi-Charge questions; combo questions are 1/3 of the total)</li>
      </ul>
      After each answer, an explanation with energy breakdown is shown to help you learn!
    </div>
    <div id="difficultyWrap">
      <label for="difficultySelect"><b>Difficulty:</b></label>
      <select id="difficultySelect">
        <option value="basic">Basic</option>
        <option value="multi">Multi-Charge</option>
        <option value="combo">Combo</option>
      </select>
    </div>
    <div id="metaSettingsWrap">
      <div id="metaBox">
        <label for="metaSelect"><b>Meta:</b></label>
        <select id="metaSelect"></select>
      </div>
      <div id="metaToggleWrap">
        <label id="metaScoreLabel" title="Only show Pokémon with score above 80 in this meta">
          <input type="checkbox" id="metaScore" />
          Only Score &gt; 80
        </label>
        <label id="metaPrefLabel" title="Only use preferred movesets for each Pokémon (from PvPoke meta)">
          <input type="checkbox" id="metaPref" />
          Preferred moveset only
        </label>
        <label id="noTrickLabel" title="Avoid 'trick questions' where every charged move always leaves 0 energy (e.g. Extrasensory/Rock Tomb)">
          <input type="checkbox" id="noTrick" />
          Avoid trick questions
        </label>
      </div>
      <div id="metaScoreExplain">
        <b>What does "Score &gt; 80" mean?</b><br>
        This limits the Pokémon pool to only those with an <b>overall score above 80 in the selected meta on <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a></b>.<br>
        Higher overall score means the Pokémon is more competitively viable in that meta.
      </div>
      <div id="metaPrefExplain">
        <b>What does "Preferred moveset only" mean?</b><br>
        This only asks about the best/most recommended movesets for each Pokémon, as listed in the selected meta's CSV (columns <b>Fast Move</b>, <b>Charged Move 1</b> and <b>Charged Move 2</b>).
      </div>
      <div id="noTrickExplain">
        <b>What does "Avoid trick questions" mean?</b><br>
        Some fast/charged move combinations (e.g. Extrasensory and Rock Tomb) always leave you with exactly 0 energy after each charged move, which means the answer for the 2nd, 3rd, etc. charged move is always exactly the same as the 1st (no leftover energy ever). When enabled, this setting avoids generating these repetitive, "trick" questions.
      </div>
      <div id="metaWarn" style="color:#b00;font-size:0.98em;padding:0.1em 0 0.2em 0;"></div>
      <div style="font-size:0.9em;color:#888;margin-top:0.2em;">
        <span>Metas loaded from <a href="https://github.com/Aeeriis/GoMovesQuiz/tree/main/rankings" target="_blank">GitHub rankings/</a> folder.</span>
      </div>
    </div>
    <div id="timerSettingsWrap">
      <label id="timerToggleLabel">
        <span class="switch">
          <input type="checkbox" id="timerToggle">
          <span class="slider"></span>
        </span>
        Show time
      </label>
      <div id="timerBox">
        <span id="timer"></span>
      </div>
    </div>
    <div id="stats"></div>
    <div id="avgstats"></div>
    <div id="loading">Loading data...</div>
    <div class="quiz-section hidden" id="quizSection">
      <div id="question"></div>
      <form id="answerForm">
        <label for="userAnswer">Your answer:</label>
        <input type="number" id="userAnswer" min="1" required autocomplete="off" />
        <button type="submit">Check</button>
      </form>
      <div class="result" id="result"></div>
      <button id="nextQuestion" class="hidden" style="display:none;">Next Question</button>
      <button id="resetStats" style="margin-top:1em;">Reset Stats</button>
    </div>
  </div>
  <div class="copyright">
    Pokémon and Pokémon GO are copyright of The Pokémon Company, Niantic, Inc., and Nintendo. All trademarked images and names are property of their respective owners, and any such material is used on this site for educational purposes only.
  </div>
  <div id="fixedNextWrap">
    <span id="fixedNextBtnWrap">
      <button id="fixedNextBtn" type="button">Next Question</button>
    </span>
  </div>
</body>
</html>
