<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pokémon Go Moveset Energy Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="manifest" href="manifest.json">
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #fafaff; }
    .container { max-width: 480px; margin: auto; padding: 1em; }
    .disclaimer {
      font-size: 0.98em;
      color: #505050;
      background: #eef3ff;
      border-radius: 8px;
      padding: 0.7em 1em;
      margin-bottom: 1.2em;
      margin-top: 0.7em;
      text-align: center;
      border: 1px solid #d0d8e8;
    }
    .copyright {
      font-size: 0.83em;
      color: #666;
      text-align: center;
      margin-top: 2.3em;
      margin-bottom: 0.7em;
      padding: 0 0.6em;
      line-height: 1.5;
    }
    h1 { font-size: 1.6em; }
    .quiz-section { margin-top: 2em; }
    .result { margin-top: 1em; font-weight: bold; }
    input[type="number"] { width: 90%; font-size: 1.2em; }
    button { font-size: 1.1em; padding: 0.6em 1.2em; margin-top: 1em;}
    label { font-size: 1.1em; }
    #question { font-size: 1.15em; margin-bottom: 1em; }
    #stats { font-size: 1.1em; margin: 0.8em 0; }
    #avgstats { font-size: 1em; margin: 0.2em 0 0.8em 0; color: #234;}
    #xpstats { font-size: 1.1em; margin: 0.1em 0 0.7em 0; color: #096; font-weight: bold;}
    #levelstats { font-size: 1.15em; margin: 0.4em 0 0.7em 0; color: #1e2a; font-weight: bold;}
    #levelupReward { font-size: 1.2em; margin: 0.6em 0 1em 0; text-align: center; }
    #difficultySelect, #timerToggle { font-size: 1em; margin-bottom: 1em;}
    #difficultyWrap { margin-bottom: 0.2em; }
    #metaSettingsWrap {
      margin: 1.2em 0 0.5em 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #metaBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.4em;
      display: flex;
      align-items: center;
      gap: 1.3em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
      flex-wrap: wrap;
    }
    #metaSelect {
      font-size: 1em;
      margin-right: 1.2em;
    }
    #metaToggleWrap {
      display: flex;
      flex-wrap: wrap;
      gap: 1.1em;
      margin-bottom: 0.15em;
      margin-left: 0.1em;
      margin-top: 0.12em;
      align-items: center;
    }
    #metaScoreLabel, #metaPrefLabel, #noTrickLabel {
      font-size: 0.97em;
      font-weight: bold;
      user-select: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 0;
      padding: 0;
    }
    #metaScore, #metaPref, #noTrick {
      vertical-align: middle;
      margin-right: 0.4em;
      accent-color: #228be6;
    }
    #metaScoreExplain, #metaPrefExplain, #noTrickExplain {
      font-size: 0.93em;
      color: #234;
      margin-top: 0.15em;
      margin-bottom: 0.13em;
      line-height: 1.35;
      padding-left: 0.1em;
    }
    #intro-explanation { margin: 1.1em 0 0.7em 0; background: #f0f7ff; border-radius: 8px; padding: 0.8em; font-size: 1.07em; color: #234; }
    #fixedNextWrap {
      display: none;
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: transparent;
      z-index: 100;
      text-align: center;
      pointer-events: none;
    }
    #fixedNextWrap.show {
      display: block;
    }
    #fixedNextBtn {
      font-size: 1.18em;
      padding: 0.75em 2.2em;
      background: #fff;
      color: #228be6;
      border: 2.5px solid #228be6;
      border-radius: 32px;
      box-shadow: 0 2px 14px #228be644, 0 1.5px 0 #eee inset;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2.5em;
      pointer-events: auto;
      transition: background .18s, color .18s, border .18s;
      position: relative;
    }
    #fixedNextBtn:hover, #fixedNextBtn:focus {
      background: #228be6;
      color: #fff;
      border-color: #228be6;
      outline: none;
    }
    #fixedNextBtn:active {
      background: #1864ab;
      color: #fff;
      border-color: #1864ab;
    }
    #fixedNextBtnWrap {
      display: inline-block;
      position: relative;
    }
    #timerSettingsWrap {
      margin-bottom: 1em;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #timerBox {
      font-size: 1.08em;
      color: #333;
      margin: 0;
      margin-bottom: 0.8em;
      display: flex;
      align-items: center;
      gap: 1.2em;
      user-select: none;
      justify-content: flex-start;
      padding-left: 0;
    }
    #timer {
      min-width: 7em;
      font-weight: bold;
      display: inline-block;
      text-align: left;
      visibility: hidden;
      transition: opacity 0.2s;
    }
    .timer-visible {
      visibility: visible !important;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 28px;
      vertical-align: middle;
      margin-right: 0.5em;
      flex-shrink: 0;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .3s;
      border-radius: 34px;
      border: 2.5px solid #bbb;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 2.7px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px #0001;
    }
    input:checked + .slider {
      background-color: #228be6;
      border-color: #228be6;
    }
    input:checked + .slider:before {
      transform: translateX(17px);
    }
    #timerToggleLabel {
      font-size: 1.07em;
      user-select: none;
      cursor: pointer;
      font-weight: bold;
      display: flex;
      align-items: center;
      margin-left: 0em;
      margin-top: 0.33em;
    }
    @media (max-width: 600px) {
      h1 { font-size: 1.2em; }
      .container { padding: 0.5em; }
      #intro-explanation { font-size: 0.97em; }
      #fixedNextBtn { font-size: 1em; padding: 0.7em 1.5em; }
      #fixedNextWrap { padding-bottom: 0em; }
      #timerBox { font-size: 1em; gap: 0.7em; }
      #timerToggleLabel { font-size: 1em; }
      #fixedNextBtn { margin-bottom: 2em; }
      #metaBox {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.3em;
      }
      #metaToggleWrap {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35em;
        margin-bottom: 0.2em;
        margin-left: 0;
      }
      #metaScoreExplain, #metaPrefExplain, #noTrickExplain { font-size: 0.88em; padding-left: 0.3em; }
      .disclaimer { font-size: 0.95em; padding: 0.56em 0.7em; }
      .copyright { font-size: 0.78em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="disclaimer">
      <b>Disclaimer:</b> This entire app was created by AI (GitHub Copilot). All gameplay and meta data used here are from <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a>.
    </div>
    <h1>Pokémon Go Moveset Energy Quiz</h1>
    <div id="intro-explanation">
      <b>How the quiz works:</b>
      <ul>
        <li><b>Basic</b> – How many fast moves do you need for the <u>first</u> charged move?</li>
        <li><b>Multi-Charge</b> – How many fast moves do you need for the <u>1st, 2nd, 3rd, or 4th</u> charged move?</li>
        <li><b>Combo</b> – After using a certain number of one charged move, how many fast moves are needed for a different charged move? (Combo mode now also includes Multi-Charge questions; combo questions are 1/3 of the total)</li>
      </ul>
      After each answer, an explanation with energy breakdown is shown to help you learn!
    </div>
    <div id="difficultyWrap">
      <label for="difficultySelect"><b>Difficulty:</b></label>
      <select id="difficultySelect">
        <option value="basic">Basic</option>
        <option value="multi">Multi-Charge</option>
        <option value="combo">Combo</option>
      </select>
    </div>
    <div id="metaSettingsWrap">
      <div id="metaBox">
        <label for="metaSelect"><b>Meta:</b></label>
        <select id="metaSelect"></select>
      </div>
      <div id="metaToggleWrap">
        <label id="metaScoreLabel" title="Only show Pokémon with score above 80 in this meta">
          <input type="checkbox" id="metaScore" />
          Only Score &gt; 80
        </label>
        <label id="metaPrefLabel" title="Only use preferred movesets for each Pokémon (from PvPoke meta)">
          <input type="checkbox" id="metaPref" />
          Preferred moveset only
        </label>
        <label id="noTrickLabel" title="Avoid 'trick questions' where every charged move always leaves 0 energy (e.g. Extrasensory/Rock Tomb)">
          <input type="checkbox" id="noTrick" />
          Avoid trick questions
        </label>
      </div>
      <div id="metaScoreExplain">
        <b>What does "Score &gt; 80" mean?</b><br>
        This limits the Pokémon pool to only those with an <b>overall score above 80 in the selected meta on <a href="https://pvpoke.com" target="_blank" rel="noopener">pvpoke.com</a></b>.<br>
        Higher overall score means the Pokémon is more competitively viable in that meta.
      </div>
      <div id="metaPrefExplain">
        <b>What does "Preferred moveset only" mean?</b><br>
        This only asks about the best/most recommended movesets for each Pokémon, as listed in the selected meta's CSV (columns <b>Fast Move</b>, <b>Charged Move 1</b> and <b>Charged Move 2</b>).
      </div>
      <div id="noTrickExplain">
        <b>What does "Avoid trick questions" mean?</b><br>
        Some fast/charged move combinations (e.g. Extrasensory and Rock Tomb) always leave you with exactly 0 energy after each charged move, which means the answer for the 2nd, 3rd, etc. charged move is always exactly the same as the 1st (no leftover energy ever). When enabled, this setting avoids generating these repetitive, "trick" questions.
      </div>
      <div id="metaWarn" style="color:#b00;font-size:0.98em;padding:0.1em 0 0.2em 0;"></div>
      <div style="font-size:0.9em;color:#888;margin-top:0.2em;">
        <span>Metas loaded from <a href="https://github.com/Aeeriis/GoMovesQuiz/tree/main/rankings" target="_blank">GitHub rankings/</a> folder.</span>
      </div>
    </div>
    <div id="timerSettingsWrap">
      <label id="timerToggleLabel">
        <span class="switch">
          <input type="checkbox" id="timerToggle">
          <span class="slider"></span>
        </span>
        Show time
      </label>
      <div id="timerBox">
        <span id="timer"></span>
      </div>
    </div>
    <div id="levelstats"></div>
    <div id="xpstats"></div>
    <div id="fruitTradeupWrap" style="margin-top:1em; text-align:center;">
  <h3>Trade Up Fruits</h3>
  <div id="tradeupOptions"></div>
  <div id="tradeupMsg" style="color:#1864ab;margin-top:0.5em;"></div>
  </div>
    <div id="levelupReward"></div>
    <div id="stats"></div>
    <div id="avgstats"></div>
    <div id="loading">Loading data...</div>
    <div class="quiz-section hidden" id="quizSection">
      <div id="question"></div>
      <form id="answerForm">
        <label for="userAnswer">Your answer:</label>
        <input type="number" id="userAnswer" min="1" required autocomplete="off" />
        <button type="submit">Check</button>
      </form>
      <div class="result" id="result"></div>
      <button id="nextQuestion" class="hidden" style="display:none;">Next Question</button>
      <button id="resetStats" style="margin-top:1em;">Reset Stats</button>
    </div>
  </div>
  <div class="copyright">
    Pokémon and Pokémon GO are copyright of The Pokémon Company, Niantic, Inc., and Nintendo. All trademarked images and names are property of their respective owners, and any such material is used on this site for educational purposes only.
  </div>
  <div id="fixedNextWrap">
    <span id="fixedNextBtnWrap">
      <button id="fixedNextBtn" type="button">Next Question</button>
    </span>
  </div>
  <script>
    // --- ANTI-FARMING STATE ---
    // This flag determines if XP has already been awarded for the current question
    let xpAwardedForCurrentQuestion = false;

    // --- XP / LEVELS / REWARDS ---
    const LEVELUP_REWARDS = [
      { emoji: "🍎", name: "Apple",        rarity: "🟢 Common", prob: 10, rarityKey: "Common" },
      { emoji: "🍌", name: "Banana",       rarity: "🟢 Common", prob: 10, rarityKey: "Common" },
      { emoji: "🍊", name: "Orange",       rarity: "🟢 Common", prob: 10, rarityKey: "Common" },
      { emoji: "🍇", name: "Grapes",       rarity: "🟢 Common", prob: 10, rarityKey: "Common" },
      { emoji: "🍉", name: "Watermelon",   rarity: "🟢 Common", prob: 10, rarityKey: "Common" },
      { emoji: "🥝", name: "Kiwi",         rarity: "🔵 Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "🍏", name: "Pomegranate",  rarity: "🔵 Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "🥭", name: "Mango",        rarity: "🔵 Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "🍐", name: "Pear",         rarity: "🔵 Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "🫐", name: "Blueberries",  rarity: "🔵 Uncommon", prob: 5, rarityKey: "Uncommon" },
      { emoji: "🐉", name: "Dragon fruit", rarity: "🟣 Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "🍈", name: "Passion fruit",rarity: "🟣 Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "🌟", name: "Starfruit",    rarity: "🟣 Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "🍒", name: "Lychee",       rarity: "🟣 Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "🍑", name: "Persimmon",    rarity: "🟣 Rare",    prob: 3, rarityKey: "Rare" },
      { emoji: "🥥", name: "Mangosteen",   rarity: "🟠 Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "🎱", name: "Rambutan",     rarity: "🟠 Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "🪷", name: "Buddha’s Hand",prob: 2, rarity: "🟠 Epic", rarityKey: "Epic" },
      { emoji: "🐍", name: "Salak",        rarity: "🟠 Epic",    prob: 2, rarityKey: "Epic" },
      { emoji: "🍄", name: "Miracle Fruit",rarity: "🔴 Legendary", prob: 0.67, rarityKey: "Legendary" },
      { emoji: "🤢", name: "Durian",       rarity: "🔴 Legendary", prob: 0.67, rarityKey: "Legendary" },
      { emoji: "🍫", name: "Cupuaçu",      rarity: "🔴 Legendary", prob: 0.66, rarityKey: "Legendary" }
    ];
    const TRADEUP_RULES = {
  Common:    { next: "Uncommon",   count: 5 },
  Uncommon:  { next: "Rare",       count: 5 },
  Rare:      { next: "Epic",       count: 3 },
  Epic:      { next: "Legendary",  count: 3 }
  // Legendary cannot be traded up
};
    function calcXP(difficulty, onlyHighScore) {
      let base = 12;
      if (difficulty === "multi") base = 17;
      else if (difficulty === "combo") base = 23;
      if (onlyHighScore) base = Math.round(base * 0.9);
      return base;
    }
    function getLevelInfo(xp) {
      let level = 1, total = 0, next = 35;
      while (xp >= total + next) {
        total += next;
        level++;
        next = level * 40;
      }
      return { level, xpInLevel: xp - total, xpToNext: next - (xp - total), xpForNext: next };
    }
    function getRandomFruitReward() {
      let r = Math.random() * 100, acc = 0;
      for (let fruit of LEVELUP_REWARDS) {
        acc += fruit.prob;
        if (r < acc) return fruit;
      }
      return LEVELUP_REWARDS[0];
    }
    let xpState = JSON.parse(localStorage.getItem('quizXP') || '{"xp":0,"fruitBag":{}}');
    if (!xpState.fruitBag) xpState.fruitBag = {};
    function saveXP() { localStorage.setItem('quizXP', JSON.stringify(xpState)); }
    function showXP() {
      const info = getLevelInfo(xpState.xp);
      document.getElementById('levelstats').textContent =
        `Level ${info.level}  |  XP: ${xpState.xp}  |  Next: ${info.xpToNext} XP`;
      let rarityOrder = ["Common","Uncommon","Rare","Epic","Legendary"];
      let rarityTitles = {
        Common: "🟢 Common",
        Uncommon: "🔵 Uncommon",
        Rare: "🟣 Rare",
        Epic: "🟠 Epic",
        Legendary: "🔴 Legendary"
      };
      function updateTradeupOptions() {
        const tradeDiv = document.getElementById('tradeupOptions');
        tradeDiv.innerHTML = '';
        let anyOption = false;
        for (let rarity in TRADEUP_RULES) {
          const rule = TRADEUP_RULES[rarity];
    // Find all fruits of this rarity in bag
          const fruits = LEVELUP_REWARDS.filter(f => f.rarityKey === rarity);
          let total = fruits.reduce((sum, f) => sum + (xpState.fruitBag[f.emoji] || 0), 0);
          if (total >= rule.count) {
              anyOption = true;
              let btn = document.createElement('button');
              btn.textContent = `Trade ${rule.count} ${rarity} fruits → 1 ${rule.next}`;
              btn.onclick = function() {
        // Remove fruits from bag
                  let needed = rule.count;
                  for (let f of fruits) {
                    let have = xpState.fruitBag[f.emoji] || 0;
                    let take = Math.min(needed, have);
                    xpState.fruitBag[f.emoji] = have - take;
                    needed -= take;
                    if (xpState.fruitBag[f.emoji] <= 0) delete xpState.fruitBag[f.emoji];
                    if (needed <= 0) break;
        }
        // Add higher-rarity fruit (pick random of next rarity)
                  let higher = LEVELUP_REWARDS.filter(f => f.rarityKey === rule.next);
                  let pick = higher[Math.floor(Math.random() * higher.length)];
                  xpState.fruitBag[pick.emoji] = (xpState.fruitBag[pick.emoji] || 0) + 1;
                  saveXP();
                  showXP();
                  updateTradeupOptions();
                  document.getElementById('tradeupMsg').textContent = `🎉 Traded up for a ${pick.emoji} ${pick.name}!`;
                  setTimeout(() => { document.getElementById('tradeupMsg').textContent = ""; }, 3000);
      };
              tradeDiv.appendChild(btn);
              tradeDiv.appendChild(document.createElement('br'));
    }
  }
          if (!anyOption) {
            tradeDiv.textContent = "No available trades.";
  }
}
      let bagByRarity = {};
      for (let fruit of LEVELUP_REWARDS) {
        let count = xpState.fruitBag[fruit.emoji] || 0;
        if (count === 0) continue;
        if (!bagByRarity[fruit.rarityKey]) bagByRarity[fruit.rarityKey] = [];
        bagByRarity[fruit.rarityKey].push({ ...fruit, count });
      }
      let bagHTML = rarityOrder.map(rarity => {
        let arr = bagByRarity[rarity];
        if (!arr || arr.length === 0) return "";
        let fruitsHTML = arr.map(f =>
          `<span title="${f.name}" style="font-size:1.4em;margin-right:0.05em">${f.emoji}×${f.count}</span>`
        ).join(" ");
        return `<><span style="font-size:1.04em">${rarityTitles[rarity]}:</span> ${fruitsHTML}</>`;
      }).join("");
      document.getElementById('xpstats').innerHTML =
        bagHTML ? `< style="margin-top:0.2em">${bagHTML}</>` : "";
    }
    function showLevelupReward(fruit) {
      let  = document.getElementById("levelupReward");
      if (!fruit) { .textContent = ""; return; }
      div.innerHTML =
        `<span style="font-size:2em;">${fruit.emoji}</span><br>` +
        `<b>Level Up!</b> You received a <b>${fruit.rarity} ${fruit.name}</b>!`;
      setTimeout(() => { div.textContent = ""; }, 5500);
    }
    // -- Meta settings (CSV file list) --
    const metaCSVFILES = [
      { file: "cp1500_all_overall_rankings.csv", label: "Great" },
      { file: "cp2500_all_overall_rankings.csv", label: "Ultra" },
      { file: "cp10000_all_overall_rankings.csv", label: "Master" },
      { file: "cp10000_premier_overall_rankings.csv", label: "Master Premier" },
      { file: "cp1500_tempo_overall_rankings.csv", label: "Tempo" },
      { file: "cp1500_wasteland_overall_rankings.csv", label: "Wasteland" },
      { file: "cp2500_battlefrontierultra_overall_rankings.csv", label: "Battlefrontier Ultra" },
      { file: "cp10000_battlefrontiermaster_overall_rankings.csv", label: "Battlefrontier Master" },
      { file: "cp1500_gbinvitational_overall_rankings.csv", label: "Gymbreakers Invitational" },
      { file: "cp1500_rivalry_overall_rankings.csv", label: "Rivalry" },
      { file: "cp1500_catch_overall_rankings.csv", label: "Catch Cup" }
    ];
    const githubUser = "Aeeriis";
    const githubRepo = "GoMovesQuiz";
    const metaRootURL = `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/main/rankings/`;

    let metaPokes = [];
    let metaPreferred = {};
    let currentMeta = localStorage.getItem("quizMeta") || metaCSVFILES[0].file;
    let onlyHighScore = localStorage.getItem("onlyHighScore") === "true";
    let onlyPreferredMoveset = localStorage.getItem("onlyPreferredMoveset") === "true";
    let avoidTrickQuestions = localStorage.getItem("avoidTrickQuestions") === "true";

    function populateMetaMenu() {
      const metaSelect = document.getElementById('metaSelect');
      metaSelect.innerHTML = "";
      metaCSVFILES.forEach(meta => {
        let opt = document.createElement("option");
        opt.value = meta.file;
        opt.textContent = meta.label;
        metaSelect.appendChild(opt);
      });
      metaSelect.value = currentMeta;
      document.getElementById('metaScore').checked = onlyHighScore;
      document.getElementById('metaPref').checked = onlyPreferredMoveset;
      document.getElementById('noTrick').checked = avoidTrickQuestions;
      loadMetaAndApply();
    }
    document.getElementById('metaSelect').onchange = function() {
      currentMeta = this.value;
      localStorage.setItem("quizMeta", currentMeta);
      loadMetaAndApply();
    };
    document.getElementById('metaScore').onchange = function() {
      onlyHighScore = this.checked;
      localStorage.setItem("onlyHighScore", onlyHighScore);
      loadMetaAndApply();
    };
    document.getElementById('metaPref').onchange = function() {
      onlyPreferredMoveset = this.checked;
      localStorage.setItem("onlyPreferredMoveset", onlyPreferredMoveset);
      loadMetaAndApply();
    };
    document.getElementById('noTrick').onchange = function() {
      avoidTrickQuestions = this.checked;
      localStorage.setItem("avoidTrickQuestions", avoidTrickQuestions);
      loadMetaAndApply();
    };

    function loadMetaAndApply() {
      document.getElementById('metaWarn').textContent = "";
      metaPreferred = {};
      if (!currentMeta) { metaPokes = []; return; }
      fetch(metaRootURL + encodeURIComponent(currentMeta))
        .then(r => r.text())
        .then(csv => {
          const lines = csv.trim().split(/\r?\n/);
          if (lines.length < 2) {
            metaPokes = [];
            document.getElementById('metaWarn').textContent = "No Pokémon found for this meta.";
            return;
          }
          const head = lines[0].split(",");
          const idxName = head.findIndex(h => h.trim().toLowerCase() === "pokemon");
          const idxScore = head.findIndex(h => h.trim().toLowerCase() === "score");
          const idxFM = head.findIndex(h => h.trim().toLowerCase() === "fast move");
          const idxC1 = head.findIndex(h => h.trim().toLowerCase() === "charged move 1");
          const idxC2 = head.findIndex(h => h.trim().toLowerCase() === "charged move 2");
          if (idxName === -1 || idxScore === -1) {
            metaPokes = [];
            document.getElementById('metaWarn').textContent = "Meta CSV missing Pokemon or Score column.";
            return;
          }
          metaPokes = [];
          metaPreferred = {};
          lines.slice(1).forEach(rowstr => {
            const row = rowstr.split(",");
            const name = row[idxName];
            const score = parseFloat(row[idxScore]);
            if (!onlyHighScore || score > 80) {
              metaPokes.push(name);
            }
            if (idxFM !== -1 && idxC1 !== -1 && idxC2 !== -1) {
              metaPreferred[name] = {
                fast: row[idxFM],
                charge1: row[idxC1],
                charge2: row[idxC2]
              };
            }
          });
          if (!metaPokes.length) {
            document.getElementById('metaWarn').textContent = "No Pokémon with Score > 80 in this meta.";
          }
          newQuestion();
        });
    }

    function isTrickCombo(fastEnergy, chargeEnergy) {
      if (!fastEnergy || !chargeEnergy) return false;
      return (chargeEnergy % fastEnergy === 0);
    }

    let stats = JSON.parse(localStorage.getItem('quizStats') ||
      '{"total":0,"correct":0,"sumTime":0,"sumTimeRight":0,"rightCount":0}');
    if (stats.sumTime === undefined) stats.sumTime = 0;
    if (stats.sumTimeRight === undefined) stats.sumTimeRight = 0;
    if (stats.rightCount === undefined) stats.rightCount = stats.correct || 0;
    function saveStats() {
      localStorage.setItem('quizStats', JSON.stringify(stats));
    }
    function showStats() {
      document.getElementById('stats').textContent =
        `Score: ${stats.correct}/${stats.total} (${stats.total ? Math.round(100 * stats.correct / stats.total) : 0}%)`;
      let avg = stats.total ? (stats.sumTime / stats.total) : 0;
      let avgRight = stats.rightCount ? (stats.sumTimeRight / stats.rightCount) : 0;
      document.getElementById('avgstats').textContent =
        `Average time: ${stats.total ? avg.toFixed(2) + " s" : "-"}   |   Average for correct: ${stats.rightCount ? avgRight.toFixed(2) + " s" : "-"}`;
    }
    showStats();
    showXP();
    updateTradeupOptions();
    let timerStart = null, timerInterval = null, timerActive = false;
    const timerSpan = document.getElementById('timer');
    const timerBox = document.getElementById('timerBox');
    const timerToggle = document.getElementById('timerToggle');
    const timerToggleLabel = document.getElementById('timerToggleLabel');
    let timerEnabled = localStorage.getItem('timerEnabled');
    if (timerEnabled === null) timerEnabled = "true";
    timerEnabled = timerEnabled === "true";
    timerToggle.checked = timerEnabled;
    function updateTimerVisibilityOnQuestion() {
      timerSpan.classList.remove('timer-visible');
      timerSpan.textContent = "";
    }
    function updateTimerVisibilityOnAnswer(timeText) {
      if (timerEnabled && timeText) {
        timerSpan.textContent = timeText;
        timerSpan.classList.add('timer-visible');
      } else {
        timerSpan.classList.remove('timer-visible');
        timerSpan.textContent = "";
      }
    }
    timerToggle.onchange = function() {
      timerEnabled = timerToggle.checked;
      localStorage.setItem('timerEnabled', timerEnabled ? "true" : "false");
      if (!timerEnabled) updateTimerVisibilityOnAnswer();
    };
    function startTimer() {
      timerStart = Date.now();
      timerActive = true;
      timerSpan.classList.remove('timer-visible');
      timerSpan.textContent = "";
      if (timerInterval) clearInterval(timerInterval);
    }
    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      timerActive = false;
    }
    function getTimerElapsed() {
      if (!timerStart) return 0;
      return (Date.now() - timerStart) / 1000;
    }
    let difficulty = localStorage.getItem("quizDifficulty") || "multi";
    document.getElementById('difficultySelect').value = difficulty;
    document.getElementById('difficultySelect').onchange = function() {
      difficulty = this.value;
      localStorage.setItem("quizDifficulty", difficulty);
      newQuestion();
    };
    document.getElementById('resetStats').onclick = function() {
      if (!window.confirm("Are you sure you want to reset your stats, XP, and fruit collection?")) return;
      stats = { total: 0, correct: 0, sumTime: 0, sumTimeRight: 0, rightCount: 0 };
      saveStats();
      showStats();
      xpState = { xp: 0, fruitBag: {} };
      saveXP();
      showXP();
      updateTradeupOptions();
    };
    function getOrdinalText(n) {
      return ["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th"][n-1] || (n+"th");
    }
    function getExplanation(pair) {
      let fastName = pair.fast.Move;
      let fastEnergy = pair.fast.Energy;
      if (pair.isCombo) {
        let chargeA = pair.combo.chargeA, nA = pair.combo.nA, chargeB = pair.charge;
        let explanation =
          `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
          `First, ${nA} <b>${chargeA.Move}</b> (Charged) are used. Each costs <b>${chargeA.Energy}</b> energy.<br>`;
        let log = [];
        let energy = 0, totalFasts = 0;
        for (let i=1; i<=nA; ++i) {
          let thisFasts = 0, startEnergy = energy;
          let movesSoFar = [];
          while (energy < chargeA.Energy) {
            energy += fastEnergy;
            totalFasts++;
            thisFasts++;
            movesSoFar.push(startEnergy + thisFasts * fastEnergy);
          }
          log.push(`For the ${getOrdinalText(i)} ${chargeA.Move}:<br>` +
            `&nbsp;&nbsp;Start with <b>${startEnergy}</b> energy.<br>` +
            `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
            `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startEnergy + thisFasts * fastEnergy}</b> energy (≥ ${chargeA.Energy} needed).<br>` +
            `&nbsp;&nbsp;You spend ${chargeA.Energy} for the charged move, leaving <b>${startEnergy + thisFasts*fastEnergy - chargeA.Energy}</b> energy for the next.<br>`
          );
          energy -= chargeA.Energy;
        }
        let beforeB = energy;
        let fastsForB = 0, breakdownB = [];
        let energyB = beforeB;
        while (energyB < chargeB.Energy) {
          energyB += fastEnergy;
          fastsForB++;
          breakdownB.push(beforeB + fastsForB * fastEnergy);
        }
        explanation += log.join('<br>') + `<br>After those, you have <b>${beforeB}</b> energy.<br>`;
        explanation += `Each fast attack gives <b>${fastEnergy}</b> energy: <b>${breakdownB.join(', ')}</b>.<br>`;
        explanation += `After ${fastsForB} fast attacks you have <b>${beforeB + fastsForB*fastEnergy}</b> energy (≥ ${chargeB.Energy} needed).<br>`;
        explanation += `You spend ${chargeB.Energy} for the charged move, leaving <b>${beforeB + fastsForB*fastEnergy - chargeB.Energy}</b> energy for the next.<br>`;
        return explanation;
      } else {
        let chargeName = pair.charge.Move;
        let chargeEnergy = pair.charge.Energy;
        let n = pair.which;
        let explanation = 
          `Each <b>${fastName}</b> (Fast) gives <b>${fastEnergy}</b> energy.<br>` +
          `You need <b>${chargeEnergy}</b> energy for each <b>${chargeName}</b> (Charged).<br>`;
        let breakdown = [];
        let energy = 0;
        for (let i = 1; i <= n; i++) {
          let thisFasts = 0;
          let startingEnergy = energy;
          let movesSoFar = [];
          while (energy < chargeEnergy) {
            energy += fastEnergy;
            thisFasts++;
            movesSoFar.push(startingEnergy + thisFasts * fastEnergy);
          }
          breakdown.push(
            `For the ${getOrdinalText(i)} charged move:<br>` +
            `&nbsp;&nbsp;Start with <b>${startingEnergy}</b> energy.<br>` +
            `&nbsp;&nbsp;Each fast attack gives <b>${fastEnergy}</b> energy: <b>${movesSoFar.join(', ')}</b>.<br>` +
            `&nbsp;&nbsp;After ${thisFasts} fast attacks you have <b>${startingEnergy + thisFasts*fastEnergy}</b> energy (≥ ${chargeEnergy} needed).<br>` +
            `&nbsp;&nbsp;You spend ${chargeEnergy} for the charged move, leaving <b>${startingEnergy + thisFasts*fastEnergy - chargeEnergy}</b> energy for the next.<br>`
          );
          energy -= chargeEnergy;
        }
        explanation += breakdown.join('<br>');
        return explanation;
      }
    }
    let moves = [], movesByName = {}, pokedex = [], currentPair = {};
    Promise.all([
      fetch('moves.csv').then(r => r.text()),
      fetch('pokemon.json').then(r => r.json())
    ]).then(([csvData, pokeData]) => {
      moves = parseCSV(csvData);
      movesByName = {};
      moves.forEach(mv => {
        movesByName[mv.Move.trim().toUpperCase().replace(/ /g, "_")] = mv;
        movesByName[mv.Move.trim()] = mv;
      });
      pokedex = pokeData;
      document.getElementById('loading').classList.add('hidden');
      document.getElementById('quizSection').classList.remove('hidden');
      showStats();
      showXP();
      updateTradeupOptions();
      populateMetaMenu();
    });
    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      return lines.slice(1).map(line => {
        let cells = [], cell = '', inQuotes = false;
        for (let ch of line) {
          if (ch === '"') inQuotes = !inQuotes;
          else if (ch === ',' && !inQuotes) { cells.push(cell); cell = ''; }
          else cell += ch;
        }
        cells.push(cell);
        let obj = {};
        headers.forEach((h, i) => {
          obj[h] = cells[i] !== undefined ? cells[i].trim() : '';
          if (['Energy'].includes(h)) {
            obj[h] = obj[h] === '' ? NaN : parseInt(obj[h], 10);
          }
        });
        return obj;
      });
    }

    function pickEligiblePokemon() {
      let eligible = pokedex.filter(poke => {
        let name = poke.speciesName;
        let fastList, chargeList;
        if (onlyPreferredMoveset && metaPreferred[name]) {
          fastList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
          chargeList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
        } else {
          fastList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
          chargeList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
        }
        return fastList.length && chargeList.length && (!metaPokes.length || metaPokes.includes(name));
      });
      if (!eligible.length) return null;
      return eligible[Math.floor(Math.random() * eligible.length)];
    }

    function getPreferredOrAllFastMoves(poke) {
      let name = poke.speciesName;
      if (onlyPreferredMoveset && metaPreferred[name]) {
        let fm = metaPreferred[name].fast;
        return [fm].filter(mv => !!movesByName[mv]);
      }
      return (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
    }
    function getPreferredOrAllChargeMoves(poke) {
      let name = poke.speciesName;
      if (onlyPreferredMoveset && metaPreferred[name]) {
        let c1 = metaPreferred[name].charge1;
        let c2 = metaPreferred[name].charge2;
        return [c1, c2].filter((mv, i, arr) => mv && arr.indexOf(mv) === i && !!movesByName[mv]);
      }
      return (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
    }

    function calcFastMovesForNthCharge(fastEnergy, chargeEnergy, n) {
      let energy = 0;
      let fastsToEachCharge = [];
      for(let i=1; i<=n; ++i) {
        let thisChargeFasts = 0;
        while (energy < chargeEnergy) {
          energy += fastEnergy;
          thisChargeFasts++;
        }
        energy -= chargeEnergy;
        fastsToEachCharge.push(thisChargeFasts);
      }
      return fastsToEachCharge[n-1];
    }
    function newQuestion() {
      // Reset anti-farming flag so XP can be awarded for the new question
      xpAwardedForCurrentQuestion = false;

      document.getElementById('result').textContent = '';
      document.getElementById('nextQuestion').classList.add('hidden');
      document.getElementById('userAnswer').value = '';
      showFixedNextButton(false);
      stopTimer();
      updateTimerVisibilityOnQuestion();
      if (!metaPokes.length) {
        document.getElementById('question').textContent = "No eligible Pokémon for this meta and filter.";
        document.getElementById('answerForm').classList.add('hidden');
        return;
      }
      if (difficulty === "basic") {
        let tries = 0, pokemon, fastList, chargeList, fast, charge;
        do {
          pokemon = pickEligiblePokemon();
          if (!pokemon) break;
          fastList = getPreferredOrAllFastMoves(pokemon);
          chargeList = getPreferredOrAllChargeMoves(pokemon);
          fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
          charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
          tries++;
        } while (
          avoidTrickQuestions &&
          isTrickCombo(fast.Energy, charge.Energy) &&
          tries < 30
        );
        if (!pokemon) {
          document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
          document.getElementById('answerForm').classList.add('hidden');
          return;
        }
        let which = 1; // Always 1st
        let nthText = getOrdinalText(which);
        let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
        currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
        document.getElementById('question').textContent =
          `How many "${fast.Move}" (Fast) are needed for the 1st "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
        document.getElementById('answerForm').classList.remove('hidden');
        startTimer();
        return;
      }
      if (difficulty === "combo") {
        if (Math.random() < 1/3) {
          let tries = 0, pokemon, fastList, chargeList, chargeAIdx, chargeBIdx, fast, chargeA, chargeB;
          do {
            let eligible = pokedex.filter(poke => {
              let name = poke.speciesName;
              let fList, cList;
              if (onlyPreferredMoveset && metaPreferred[name]) {
                fList = [metaPreferred[name].fast].filter(mv => !!movesByName[mv]);
                cList = [metaPreferred[name].charge1, metaPreferred[name].charge2].filter(mv => !!movesByName[mv]);
              } else {
                fList = (poke.fastMoves || []).filter(mv => !!movesByName[mv]);
                cList = (poke.chargedMoves || []).filter(mv => !!movesByName[mv]);
              }
              return fList.length && cList.length >= 2 && (!metaPokes.length || metaPokes.includes(name));
            });
            if (!eligible.length) break;
            pokemon = eligible[Math.floor(Math.random() * eligible.length)];
            fastList = getPreferredOrAllFastMoves(pokemon);
            chargeList = getPreferredOrAllChargeMoves(pokemon);
            chargeAIdx = Math.floor(Math.random() * chargeList.length);
            do { chargeBIdx = Math.floor(Math.random() * chargeList.length); } while (chargeBIdx === chargeAIdx);
            fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
            chargeA = movesByName[chargeList[chargeAIdx]];
            chargeB = movesByName[chargeList[chargeBIdx]];
            tries++;
          } while (
            avoidTrickQuestions &&
            isTrickCombo(fast.Energy, chargeA.Energy) &&
            isTrickCombo(fast.Energy, chargeB.Energy) &&
            tries < 30
          );
          if (!pokemon) return newQuestion();
          let nA = 1 + Math.floor(Math.random() * 3); // 1-3 times
          let energy = 0, totalFasts = 0;
          for (let i=0; i<nA; ++i) {
            while (energy < chargeA.Energy) {
              energy += fast.Energy;
              totalFasts++;
            }
            energy -= chargeA.Energy;
          }
          let neededFastsForB = 0;
          let currentEnergy = energy;
          while (currentEnergy < chargeB.Energy) {
            currentEnergy += fast.Energy;
            neededFastsForB++;
          }
          currentPair = {
            fast, charge: chargeB, pokemon, needed: neededFastsForB, isCombo: true,
            combo: { chargeA, nA, leftover: energy }
          };
          document.getElementById('question').textContent =
            `${pokemon.speciesName} with ${fast.Move} (Fast) has thrown ${nA} ${chargeA.Move} (Charged).` +
            ` How many more ${fast.Move} are needed for a ${chargeB.Move} (Charged) now?`;
          document.getElementById('answerForm').classList.remove('hidden');
          startTimer();
          return;
        } else {
          let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
          do {
            pokemon = pickEligiblePokemon();
            if (!pokemon) break;
            fastList = getPreferredOrAllFastMoves(pokemon);
            chargeList = getPreferredOrAllChargeMoves(pokemon);
            fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
            charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
            which = 1 + Math.floor(Math.random() * 4); // 1~4
            tries++;
          } while (
            avoidTrickQuestions &&
            isTrickCombo(fast.Energy, charge.Energy) &&
            which > 1 &&
            tries < 30
          );
          if (!pokemon) {
            document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
            document.getElementById('answerForm').classList.add('hidden');
            return;
          }
          let nthText = getOrdinalText(which);
          let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
          currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
          document.getElementById('question').textContent =
            `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
          document.getElementById('answerForm').classList.remove('hidden');
          startTimer();
          return;
        }
      }
      let tries = 0, pokemon, fastList, chargeList, fast, charge, which;
      do {
        pokemon = pickEligiblePokemon();
        if (!pokemon) break;
        fastList = getPreferredOrAllFastMoves(pokemon);
        chargeList = getPreferredOrAllChargeMoves(pokemon);
        fast = movesByName[fastList[Math.floor(Math.random() * fastList.length)]];
        charge = movesByName[chargeList[Math.floor(Math.random() * chargeList.length)]];
        which = 1 + Math.floor(Math.random() * 4); // 1~4
        tries++;
      } while (
        avoidTrickQuestions &&
        isTrickCombo(fast.Energy, charge.Energy) &&
        which > 1 &&
        tries < 30
      );
      if (!pokemon) {
        document.getElementById('question').textContent = 'No eligible Pokémon found. Please check your data files.';
        document.getElementById('answerForm').classList.add('hidden');
        return;
      }
      let nthText = getOrdinalText(which);
      let needed = calcFastMovesForNthCharge(fast.Energy, charge.Energy, which);
      currentPair = { fast, charge, pokemon, needed, which, nthText, isCombo: false };
      document.getElementById('question').textContent =
        `How many "${fast.Move}" (Fast) are needed for the ${nthText} "${charge.Move}" (Charged) for ${pokemon.speciesName}?`;
      document.getElementById('answerForm').classList.remove('hidden');
      startTimer();
    }

    document.getElementById('answerForm').addEventListener('submit', function(e) {
      e.preventDefault();

      // --- Prevent XP farming: if XP has already been awarded for this question, just show the result and explanation, but do NOT give XP/stats again ---
      if (xpAwardedForCurrentQuestion) {
        // Show the result and explanation again, but do not update stats/xp
        const userAnswer = parseInt(document.getElementById('userAnswer').value, 10);
        let wasCorrect = (userAnswer === currentPair.needed);
        document.getElementById('result').textContent = wasCorrect ? '✅ Correct!' : `❌ Incorrect. The correct answer is ${currentPair.needed}.`;
        let timeText = "";
        let elapsed = 0;
        if (timerEnabled && typeof timerStart === "number" && timerStart > 0) {
          elapsed = getTimerElapsed();
          timeText = "Answered in " + elapsed.toFixed(2) + " s";
        }
        updateTimerVisibilityOnAnswer(timeText);
        if (timerEnabled && timeText) {
          document.getElementById('result').innerHTML +=
            `<br><span style="color:#228be6;font-weight:bold;">${timeText}</span>`;
        }
        document.getElementById('result').innerHTML +=
          "<br><span style='font-size:0.95em;color:#555;'>" + getExplanation(currentPair) + "</span>";
        showFixedNextButton(true);
        return; // Early exit: do not award xp/stats again
      }

      stopTimer();
      const userAnswer = parseInt(document.getElementById('userAnswer').value, 10);
      let wasCorrect = false;
      if (userAnswer === currentPair.needed) {
        document.getElementById('result').textContent = '✅ Correct!';
        wasCorrect = true;
      } else {
        document.getElementById('result').textContent =
          `❌ Incorrect. The correct answer is ${currentPair.needed}.`;
      }
      let timeText = "";
      let elapsed = 0;
      if (timerEnabled && typeof timerStart === "number" && timerStart > 0) {
        elapsed = getTimerElapsed();
        timeText = "Answered in " + elapsed.toFixed(2) + " s";
      }
      if (typeof elapsed === "number" && elapsed > 0) {
        stats.sumTime = (stats.sumTime || 0) + elapsed;
        if (wasCorrect) {
          stats.sumTimeRight = (stats.sumTimeRight || 0) + elapsed;
          stats.rightCount = (stats.rightCount || 0) + 1;
        }
      }
      updateTimerVisibilityOnAnswer(timeText);
      if (timerEnabled && timeText) {
        document.getElementById('result').innerHTML +=
          `<br><span style="color:#228be6;font-weight:bold;">${timeText}</span>`;
      }
      document.getElementById('result').innerHTML +=
        "<br><span style='font-size:0.95em;color:#555;'>" + getExplanation(currentPair) + "</span>";
      showFixedNextButton(true);

      stats.total++;
      if (wasCorrect) stats.correct++;
      saveStats();
      showStats();

      // --- AWARD XP ONLY ON FIRST SUBMIT for this question ---
      if (wasCorrect && !xpAwardedForCurrentQuestion) {
        xpAwardedForCurrentQuestion = true; // Mark this question as "xp already given"
        const xpGain = calcXP(difficulty, onlyHighScore);
        let prevXP = xpState.xp;
        xpState.xp += xpGain;
        let prevLevel = getLevelInfo(prevXP).level;
        let newLevel = getLevelInfo(xpState.xp).level;
        saveXP();
        showXP();
        updateTradeupOptions();
        if (newLevel > prevLevel) {
          let fruit = getRandomFruitReward();
          if (!xpState.fruitBag[fruit.emoji]) xpState.fruitBag[fruit.emoji] = 0;
          xpState.fruitBag[fruit.emoji]++;
          saveXP();
          showXP();
          updateTradeupOptions();
          showLevelupReward(fruit);
        } else {
          showLevelupReward(null);
        }
      } else {
        showLevelupReward(null);
      }
    });

    const fixedNextWrap = document.getElementById('fixedNextWrap');
    const fixedNextBtn = document.getElementById('fixedNextBtn');
    function showFixedNextButton(show) {
      if (show) fixedNextWrap.classList.add('show');
      else fixedNextWrap.classList.remove('show');
    }
    fixedNextBtn.onclick = function() {
      showFixedNextButton(false);
      newQuestion();
    };
    document.getElementById('nextQuestion').style.display = "none";
  </script>
</body>
</html>
